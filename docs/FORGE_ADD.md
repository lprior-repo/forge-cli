# forge add - Add AWS Resources

The `forge add` command generates Terraform code for AWS resources with automatic wiring and best practices built-in.

## Table of Contents

- [Overview](#overview)
- [Quick Start](#quick-start)
- [Supported Resources](#supported-resources)
- [Command Syntax](#command-syntax)
- [Examples](#examples)
- [Resource Options](#resource-options)
- [Integration Patterns](#integration-patterns)
- [Generated Files](#generated-files)
- [Architecture](#architecture)
- [Testing](#testing)

## Overview

`forge add` is a **code generation tool** that creates production-ready Terraform code for common serverless patterns. Unlike traditional infrastructure-as-code tools that require manual resource configuration, `forge add` generates complete, working Terraform with:

- **Sensible defaults** that follow AWS best practices
- **Automatic resource wiring** (e.g., Lambda event sources, IAM policies)
- **Namespace support** for ephemeral PR environments
- **Module-based or raw resources** (user choice)
- **Zero lock-in** - all generated code is editable Terraform

### Key Features

1. **Convention over Configuration**: Uses smart defaults, minimal flags required
2. **Automatic Integration**: Wires resources together with correct IAM permissions
3. **Namespace-Aware**: All resources support `var.namespace` prefix for PR environments
4. **Pure Functional**: Generation logic is pure functions with Either monad error handling
5. **Extensible**: Plugin architecture for adding new resource types

## Quick Start

### Add a Standalone SQS Queue

```bash
forge add sqs orders-queue
```

Generates:
- `infra/sqs.tf` - SQS queue module with DLQ
- `infra/outputs.tf` - Queue URL and ARN outputs

### Add SQS Queue with Lambda Integration

```bash
forge add sqs orders-queue --to=processor
```

Generates:
- `infra/sqs.tf` - SQS queue module
- `infra/outputs.tf` - Queue outputs
- `infra/lambda_processor.tf` - Event source mapping + IAM policy

### Use Raw Resources Instead of Modules

```bash
forge add sqs orders-queue --raw
```

Uses `aws_sqs_queue` resource instead of `terraform-aws-modules/sqs/aws` module.

## Supported Resources

### Phase 1 (Current)

| Resource Type | Command | Description |
|--------------|---------|-------------|
| **SQS** | `forge add sqs <name>` | SQS queue with optional DLQ and Lambda integration |

### Phase 2 (Planned)

| Resource Type | Command | Description |
|--------------|---------|-------------|
| **DynamoDB** | `forge add dynamodb <name>` | DynamoDB table with GSI/LSI support |
| **SNS** | `forge add sns <name>` | SNS topic with subscriptions |
| **S3** | `forge add s3 <name>` | S3 bucket with event notifications |
| **API Gateway** | `forge add apigw <name>` | HTTP API with routes |
| **EventBridge** | `forge add eventbridge <name>` | EventBridge bus with rules |
| **Step Functions** | `forge add sfn <name>` | State machine definition |

## Command Syntax

```bash
forge add <resource-type> <name> [flags]
```

### Arguments

- `<resource-type>` - Type of resource to add (sqs, dynamodb, sns, etc.)
- `<name>` - Name for the resource (alphanumeric, hyphens, underscores)

### Flags

| Flag | Type | Default | Description |
|------|------|---------|-------------|
| `--to` | string | "" | Target Lambda function for integration |
| `--raw` | bool | false | Generate raw Terraform resources instead of modules |
| `--no-module` | bool | false | Alias for --raw |

### Exit Codes

| Code | Meaning |
|------|---------|
| 0 | Success |
| 1 | Invalid arguments or configuration |
| 2 | Resource generation failed |
| 3 | File write failed |

## Examples

### Example 1: Standalone SQS Queue

```bash
forge add sqs orders-queue
```

**Generated `infra/sqs.tf`:**

```hcl
# Generated by forge add sqs orders-queue

module "orders_queue" {
  source  = "terraform-aws-modules/sqs/aws"
  version = "~> 4.0"

  name = "${var.namespace}orders-queue"

  visibility_timeout_seconds = 30
  message_retention_seconds  = 345600

  # Dead letter queue for failed messages
  create_dlq                    = true
  dlq_name                      = "${var.namespace}orders-queue-dlq"
  dlq_message_retention_seconds = 1209600  # 14 days

  tags = {
    ManagedBy = "forge"
    Namespace = var.namespace
  }
}
```

**Generated `infra/outputs.tf`:**

```hcl
# Outputs for orders-queue
output "orders_queue_url" {
  description = "URL of orders-queue"
  value       = module.orders_queue.queue_url
}

output "orders_queue_arn" {
  description = "ARN of orders-queue"
  value       = module.orders_queue.queue_arn
}
```

### Example 2: SQS Queue with Lambda Integration

```bash
forge add sqs orders-queue --to=processor
```

**Additional Generated `infra/lambda_processor.tf`:**

```hcl
# SQS event source mapping for orders-queue
resource "aws_lambda_event_source_mapping" "processor_orders_queue" {
  event_source_arn = module.orders_queue.queue_arn
  function_name    = aws_lambda_function.processor.arn

  batch_size                         = 10
  maximum_batching_window_in_seconds = 5

  scaling_config {
    maximum_concurrency = 10
  }
}

# IAM policy for processor to access orders-queue
resource "aws_iam_role_policy" "processor_sqs_orders_queue" {
  name = "${var.namespace}processor-sqs-orders_queue"
  role = aws_iam_role.processor.id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Action = [
          "sqs:ReceiveMessage",
          "sqs:DeleteMessage",
          "sqs:GetQueueAttributes"
        ]
        Resource = module.orders_queue.queue_arn
      }
    ]
  })
}
```

### Example 3: Raw Resources (No Modules)

```bash
forge add sqs orders-queue --raw
```

**Generated `infra/sqs.tf`:**

```hcl
# Generated by forge add sqs orders-queue --raw

resource "aws_sqs_queue" "orders_queue" {
  name = "${var.namespace}orders-queue"

  visibility_timeout_seconds = 30
  message_retention_seconds  = 345600

  tags = {
    ManagedBy = "forge"
    Namespace = var.namespace
  }
}
```

**Generated `infra/outputs.tf`:**

```hcl
# Outputs for orders-queue
output "orders_queue_url" {
  description = "URL of orders-queue"
  value       = aws_sqs_queue.orders_queue.url
}

output "orders_queue_arn" {
  description = "ARN of orders-queue"
  value       = aws_sqs_queue.orders_queue.arn
}
```

## Resource Options

### SQS Queue Options

**Default Configuration:**

```go
visibility_timeout_seconds: 30        // Lambda timeout + buffer
message_retention_seconds:  345600    // 4 days
create_dlq:                 true      // Dead letter queue enabled
dlq_message_retention_seconds: 1209600 // 14 days
```

**Integration Configuration (when --to flag used):**

```go
batch_size:             10   // Messages per Lambda invocation
max_batching_window:    5    // Seconds to wait for full batch
max_concurrency:        10   // Concurrent Lambda invocations
```

**IAM Permissions (Lambda integration):**

- `sqs:ReceiveMessage` - Read messages from queue
- `sqs:DeleteMessage` - Remove processed messages
- `sqs:GetQueueAttributes` - Query queue metadata

## Integration Patterns

### Pattern 1: Queue-Triggered Lambda

```bash
# 1. Add Lambda function
forge new my-app --runtime=go
# (manually add processor function to src/functions/)

# 2. Add SQS queue with integration
forge add sqs orders-queue --to=processor

# 3. Deploy
forge deploy
```

**Result**: Lambda is automatically triggered when messages arrive in queue.

### Pattern 2: Multiple Consumers

```bash
# Add queue
forge add sqs orders-queue

# Wire to multiple Lambdas
forge add sqs orders-queue --to=processor-a
forge add sqs orders-queue --to=processor-b
```

**Note**: Currently requires manual coordination. Phase 2 will support fan-out patterns.

### Pattern 3: Namespace Isolation

```bash
# Production deployment
forge deploy

# PR preview environment
forge deploy --namespace=pr-123
```

**Result**: Two isolated environments:
- Production: `orders-queue`
- PR: `pr-123-orders-queue`

All resources are isolated by namespace prefix.

## Generated Files

### File Write Modes

`forge add` uses three file write modes:

1. **Create**: Creates new file, skips if exists
2. **Append**: Appends to existing file or creates new
3. **Update**: Updates existing resource or appends (Phase 2)

### File Locations

All files are written to `infra/` directory:

| File | Purpose | Write Mode |
|------|---------|------------|
| `sqs.tf` | SQS resource definitions | Append |
| `outputs.tf` | Output values | Append |
| `lambda_<func>.tf` | Lambda integrations | Append |

### Namespace Support

All generated resources use `${var.namespace}` prefix:

```hcl
name = "${var.namespace}orders-queue"
```

This enables ephemeral PR environments:

```bash
# Default (empty namespace)
terraform apply
# Creates: orders-queue

# PR environment
terraform apply -var="namespace=pr-123-"
# Creates: pr-123-orders-queue
```

## Architecture

### Generator Interface

All resource generators implement:

```go
type Generator interface {
    // Prompt gathers configuration from user (I/O ACTION)
    Prompt(ctx context.Context, intent ResourceIntent, state ProjectState) E.Either[error, ResourceConfig]

    // Generate creates Terraform code from configuration (PURE CALCULATION)
    Generate(config ResourceConfig, state ProjectState) E.Either[error, GeneratedCode]

    // Validate checks if configuration is valid (PURE CALCULATION)
    Validate(config ResourceConfig) E.Either[error, ResourceConfig]
}
```

### Pipeline Flow

```
User Command
    ↓
Parse Arguments → ResourceIntent
    ↓
Discover Project State → ProjectState
    ↓
Generator.Prompt() → ResourceConfig
    ↓
Generator.Validate() → ResourceConfig
    ↓
Generator.Generate() → GeneratedCode
    ↓
Write Files → WrittenFiles
    ↓
Report Results
```

### Pure Functional Design

**Calculations (Pure Functions):**
- `Generator.Generate()` - Same inputs always produce same outputs
- `Generator.Validate()` - No side effects
- `generateModuleCode()` - String transformation only

**Actions (I/O Functions):**
- `Generator.Prompt()` - May read user input (future: interactive TUI)
- `discoverProjectState()` - Reads filesystem
- `writeGeneratedFiles()` - Writes to disk

**Data (Immutable Structures):**
- `ResourceIntent` - User's command intent
- `ResourceConfig` - Validated configuration
- `GeneratedCode` - Files to write

### Error Handling

Uses Either monad for railway-oriented programming:

```go
func Generate(config ResourceConfig) E.Either[error, GeneratedCode] {
    // Automatic error short-circuiting
    // No error if-checks needed
}
```

All errors are returned via `E.Left[T]`, success via `E.Right[error]`.

## Testing

### Unit Tests

**Run all generator tests:**

```bash
task test:unit
```

**Test specific generator:**

```bash
go test ./internal/generators/sqs/... -v
```

### Integration Tests

**Test full `forge add` workflow:**

```bash
task test:integration
```

### Coverage

**Check test coverage:**

```bash
task coverage:check
```

**Target**: 90% minimum coverage across all packages.

### Example Test

```go
func TestGenerate_WithIntegration(t *testing.T) {
    gen := sqs.New()

    config := generators.ResourceConfig{
        Type:   generators.ResourceSQS,
        Name:   "orders-queue",
        Module: true,
        Integration: &generators.IntegrationConfig{
            TargetFunction: "processor",
            EventSource: &generators.EventSourceConfig{
                ARNExpression: "module.orders_queue.queue_arn",
                BatchSize:     10,
            },
        },
    }

    result := gen.Generate(config, generators.ProjectState{})

    require.True(t, E.IsRight(result))
    code := E.GetRight(result)

    assert.Len(t, code.Files, 3) // sqs.tf, outputs.tf, lambda_processor.tf
}
```

## Troubleshooting

### Error: "infra/ directory not found"

**Solution**: Run `forge new <project>` first to scaffold project structure.

### Error: "target function 'X' not found"

**Solution**: Ensure Lambda function exists in Terraform before adding integration:

```bash
# Check existing functions
ls infra/lambda_*.tf
```

### Error: "unsupported resource type"

**Solution**: Check supported resources with `forge add --help`. New resource types coming in future phases.

### Generated code has syntax errors

**Solution**: This is a bug. Please report with:
1. Command used
2. Generated file content
3. Terraform version

```bash
# Validate Terraform syntax
cd infra
terraform fmt -check
terraform validate
```

### Files not being created

**Solution**: Check directory permissions:

```bash
ls -la infra/
```

Ensure write permissions for current user.

## Next Steps

After running `forge add`:

1. **Review Generated Code**
   ```bash
   cat infra/sqs.tf
   cat infra/outputs.tf
   ```

2. **Initialize Terraform** (if first time)
   ```bash
   cd infra
   terraform init
   ```

3. **Plan Deployment**
   ```bash
   terraform plan
   ```

4. **Deploy Resources**
   ```bash
   terraform apply
   ```

5. **Verify Deployment**
   ```bash
   terraform output orders_queue_url
   ```

## Future Enhancements

### Phase 2: Enhanced Discovery

- Parse existing `.tf` files to populate `ProjectState`
- Detect existing functions, queues, tables automatically
- Smart validation: "Function 'X' already has 2 SQS triggers"

### Phase 3: Interactive TUI

- Bubbletea-based configuration UI
- Visual resource selection
- Real-time validation feedback
- Preview generated code before writing

### Phase 4: Smart Updates

- Update existing resources instead of appending
- HCL parsing and manipulation
- Resource versioning and migration

### Phase 5: More Resources

- DynamoDB with streams
- API Gateway with routes
- EventBridge rules
- Step Functions state machines
- S3 with notifications

## Related Documentation

- [CLI Reference](CLI_REFERENCE.md) - Complete CLI documentation
- [API Reference](API_REFERENCE.md) - Go package APIs
- [VISION.md](../VISION.md) - Project philosophy
- [TECHNICAL_DECISIONS.md](../TECHNICAL_DECISIONS.md) - Architecture rationale

## Contributing

To add a new resource generator:

1. Create `internal/generators/<resource>/generator.go`
2. Implement `Generator` interface
3. Add tests in `generator_test.go`
4. Register in `internal/cli/add.go`
5. Update this documentation

See `internal/generators/sqs/` for reference implementation.
