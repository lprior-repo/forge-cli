// Package sqs provides SQS queue generation for forge add sqs command.
// It follows functional programming principles with pure generation logic.
package sqs

import (
	"context"
	"fmt"
	"strings"

	E "github.com/IBM/fp-go/either"
	"github.com/lewis/forge/internal/generators"
)

// Generator implements generators.Generator for SQS queues
type Generator struct{}

// New creates a new SQS generator
func New() *Generator {
	return &Generator{}
}

// Prompt gathers configuration from user (I/O ACTION)
func (g *Generator) Prompt(ctx context.Context, intent generators.ResourceIntent, state generators.ProjectState) E.Either[error, generators.ResourceConfig] {
	// For MVP, use sensible defaults
	// In Phase 6, this will launch interactive TUI

	config := generators.ResourceConfig{
		Type:   generators.ResourceSQS,
		Name:   intent.Name,
		Module: intent.UseModule, // Default to module-based
		Variables: map[string]interface{}{
			"visibility_timeout_seconds": 30,
			"message_retention_seconds":  345600, // 4 days
			"create_dlq":                 true,
		},
	}

	// If integrating with Lambda, add integration config
	if intent.ToFunc != "" {
		// Verify target function exists
		if _, exists := state.Functions[intent.ToFunc]; !exists {
			return E.Left[generators.ResourceConfig](
				fmt.Errorf("target function '%s' not found", intent.ToFunc),
			)
		}

		config.Integration = &generators.IntegrationConfig{
			TargetFunction: intent.ToFunc,
			EventSource: &generators.EventSourceConfig{
				ARNExpression:         fmt.Sprintf("module.%s.queue_arn", sanitizeName(intent.Name)),
				BatchSize:             10,
				MaxBatchingWindowSecs: 5,
				MaxConcurrency:        10,
			},
			IAMPermissions: []generators.IAMPermission{
				{
					Effect: "Allow",
					Actions: []string{
						"sqs:ReceiveMessage",
						"sqs:DeleteMessage",
						"sqs:GetQueueAttributes",
					},
					Resources: []string{
						fmt.Sprintf("module.%s.queue_arn", sanitizeName(intent.Name)),
					},
				},
			},
		}
	}

	return E.Right[error](config)
}

// Generate creates Terraform code from configuration (PURE CALCULATION)
func (g *Generator) Generate(config generators.ResourceConfig, state generators.ProjectState) E.Either[error, generators.GeneratedCode] {
	// Validate first, then chain generation - automatic error short-circuiting
	return E.Chain(func(validConfig generators.ResourceConfig) E.Either[error, generators.GeneratedCode] {
		var files []generators.FileToWrite

		// 1. Generate main SQS resource file
		if validConfig.Module {
			files = append(files, generators.FileToWrite{
				Path:    "sqs.tf",
				Content: generateModuleCode(validConfig),
				Mode:    generators.WriteModeAppend,
			})
		} else {
			files = append(files, generators.FileToWrite{
				Path:    "sqs.tf",
				Content: generateRawResourceCode(validConfig),
				Mode:    generators.WriteModeAppend,
			})
		}

		// 2. Generate outputs
		files = append(files, generators.FileToWrite{
			Path:    "outputs.tf",
			Content: generateOutputs(validConfig),
			Mode:    generators.WriteModeAppend,
		})

		// 3. If integration, update Lambda function file
		if validConfig.Integration != nil {
			lambdaFile := fmt.Sprintf("lambda_%s.tf", validConfig.Integration.TargetFunction)
			files = append(files, generators.FileToWrite{
				Path:    lambdaFile,
				Content: generateIntegrationCode(validConfig),
				Mode:    generators.WriteModeAppend,
			})
		}

		return E.Right[error](generators.GeneratedCode{
			Files: files,
		})
	})(g.Validate(config))
}

// Validate checks if configuration is valid (PURE CALCULATION)
func (g *Generator) Validate(config generators.ResourceConfig) E.Either[error, generators.ResourceConfig] {
	if config.Name == "" {
		return E.Left[generators.ResourceConfig](
			fmt.Errorf("queue name is required"),
		)
	}

	if !isValidName(config.Name) {
		return E.Left[generators.ResourceConfig](
			fmt.Errorf("queue name must be alphanumeric with hyphens/underscores"),
		)
	}

	return E.Right[error](config)
}

// generateModuleCode creates Terraform module code (PURE)
func generateModuleCode(config generators.ResourceConfig) string {
	moduleName := sanitizeName(config.Name)
	queueName := config.Name

	visibilityTimeout := config.Variables["visibility_timeout_seconds"].(int)
	messageRetention := config.Variables["message_retention_seconds"].(int)
	createDLQ := config.Variables["create_dlq"].(bool)

	var parts []string

	parts = append(parts, "# Generated by forge add sqs "+config.Name)
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("module \"%s\" {", moduleName))
	parts = append(parts, "  source  = \"terraform-aws-modules/sqs/aws\"")
	parts = append(parts, "  version = \"~> 4.0\"")
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("  name = \"${var.namespace}%s\"", queueName))
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("  visibility_timeout_seconds = %d", visibilityTimeout))
	parts = append(parts, fmt.Sprintf("  message_retention_seconds  = %d", messageRetention))

	if createDLQ {
		parts = append(parts, "")
		parts = append(parts, "  # Dead letter queue for failed messages")
		parts = append(parts, "  create_dlq                    = true")
		parts = append(parts, fmt.Sprintf("  dlq_name                      = \"${var.namespace}%s-dlq\"", queueName))
		parts = append(parts, "  dlq_message_retention_seconds = 1209600  # 14 days")
	}

	parts = append(parts, "")
	parts = append(parts, "  tags = {")
	parts = append(parts, "    ManagedBy = \"forge\"")
	parts = append(parts, "    Namespace = var.namespace")
	parts = append(parts, "  }")
	parts = append(parts, "}")
	parts = append(parts, "")

	return strings.Join(parts, "\n")
}

// generateRawResourceCode creates raw Terraform resource code (PURE)
func generateRawResourceCode(config generators.ResourceConfig) string {
	resourceName := sanitizeName(config.Name)
	queueName := config.Name

	visibilityTimeout := config.Variables["visibility_timeout_seconds"].(int)
	messageRetention := config.Variables["message_retention_seconds"].(int)

	var parts []string

	parts = append(parts, "# Generated by forge add sqs "+config.Name+" --raw")
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("resource \"aws_sqs_queue\" \"%s\" {", resourceName))
	parts = append(parts, fmt.Sprintf("  name = \"${var.namespace}%s\"", queueName))
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("  visibility_timeout_seconds = %d", visibilityTimeout))
	parts = append(parts, fmt.Sprintf("  message_retention_seconds  = %d", messageRetention))
	parts = append(parts, "")
	parts = append(parts, "  tags = {")
	parts = append(parts, "    ManagedBy = \"forge\"")
	parts = append(parts, "    Namespace = var.namespace")
	parts = append(parts, "  }")
	parts = append(parts, "}")
	parts = append(parts, "")

	return strings.Join(parts, "\n")
}

// generateOutputs creates Terraform outputs (PURE)
func generateOutputs(config generators.ResourceConfig) string {
	moduleName := sanitizeName(config.Name)

	var parts []string

	parts = append(parts, "# Outputs for "+config.Name)

	if config.Module {
		parts = append(parts, fmt.Sprintf("output \"%s_url\" {", moduleName))
		parts = append(parts, fmt.Sprintf("  description = \"URL of %s\"", config.Name))
		parts = append(parts, fmt.Sprintf("  value       = module.%s.queue_url", moduleName))
		parts = append(parts, "}")
		parts = append(parts, "")
		parts = append(parts, fmt.Sprintf("output \"%s_arn\" {", moduleName))
		parts = append(parts, fmt.Sprintf("  description = \"ARN of %s\"", config.Name))
		parts = append(parts, fmt.Sprintf("  value       = module.%s.queue_arn", moduleName))
		parts = append(parts, "}")
	} else {
		parts = append(parts, fmt.Sprintf("output \"%s_url\" {", moduleName))
		parts = append(parts, fmt.Sprintf("  description = \"URL of %s\"", config.Name))
		parts = append(parts, fmt.Sprintf("  value       = aws_sqs_queue.%s.url", moduleName))
		parts = append(parts, "}")
		parts = append(parts, "")
		parts = append(parts, fmt.Sprintf("output \"%s_arn\" {", moduleName))
		parts = append(parts, fmt.Sprintf("  description = \"ARN of %s\"", config.Name))
		parts = append(parts, fmt.Sprintf("  value       = aws_sqs_queue.%s.arn", moduleName))
		parts = append(parts, "}")
	}

	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// generateIntegrationCode creates Lambda event source mapping (PURE)
func generateIntegrationCode(config generators.ResourceConfig) string {
	if config.Integration == nil {
		return ""
	}

	queueName := sanitizeName(config.Name)
	functionName := config.Integration.TargetFunction
	eventSource := config.Integration.EventSource

	var parts []string

	// Event source mapping
	parts = append(parts, fmt.Sprintf("# SQS event source mapping for %s", config.Name))
	parts = append(parts, fmt.Sprintf("resource \"aws_lambda_event_source_mapping\" \"%s_%s\" {",
		functionName, queueName))
	parts = append(parts, fmt.Sprintf("  event_source_arn = %s", eventSource.ARNExpression))
	parts = append(parts, fmt.Sprintf("  function_name    = aws_lambda_function.%s.arn", functionName))
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("  batch_size                         = %d", eventSource.BatchSize))
	parts = append(parts, fmt.Sprintf("  maximum_batching_window_in_seconds = %d", eventSource.MaxBatchingWindowSecs))
	parts = append(parts, "")
	parts = append(parts, "  scaling_config {")
	parts = append(parts, fmt.Sprintf("    maximum_concurrency = %d", eventSource.MaxConcurrency))
	parts = append(parts, "  }")
	parts = append(parts, "}")
	parts = append(parts, "")

	// IAM policy for SQS access
	parts = append(parts, fmt.Sprintf("# IAM policy for %s to access %s", functionName, config.Name))
	parts = append(parts, fmt.Sprintf("resource \"aws_iam_role_policy\" \"%s_sqs_%s\" {",
		functionName, queueName))
	parts = append(parts, fmt.Sprintf("  name = \"${var.namespace}%s-sqs-%s\"", functionName, queueName))
	parts = append(parts, fmt.Sprintf("  role = aws_iam_role.%s.id", functionName))
	parts = append(parts, "")
	parts = append(parts, "  policy = jsonencode({")
	parts = append(parts, "    Version = \"2012-10-17\"")
	parts = append(parts, "    Statement = [")
	parts = append(parts, "      {")
	parts = append(parts, "        Effect = \"Allow\"")
	parts = append(parts, "        Action = [")

	for i, action := range config.Integration.IAMPermissions[0].Actions {
		comma := ","
		if i == len(config.Integration.IAMPermissions[0].Actions)-1 {
			comma = ""
		}
		parts = append(parts, fmt.Sprintf("          \"%s\"%s", action, comma))
	}

	parts = append(parts, "        ]")
	parts = append(parts, fmt.Sprintf("        Resource = %s", config.Integration.IAMPermissions[0].Resources[0]))
	parts = append(parts, "      }")
	parts = append(parts, "    ]")
	parts = append(parts, "  })")
	parts = append(parts, "}")
	parts = append(parts, "")

	return strings.Join(parts, "\n")
}

// sanitizeName converts a name to a valid Terraform identifier (PURE)
func sanitizeName(name string) string {
	// Replace hyphens with underscores for Terraform identifiers
	return strings.ReplaceAll(name, "-", "_")
}

// isValidName checks if a name is valid (PURE)
func isValidName(name string) bool {
	if len(name) == 0 {
		return false
	}

	for _, r := range name {
		if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') ||
			(r >= '0' && r <= '9') || r == '-' || r == '_') {
			return false
		}
	}

	return true
}
