// Package sns provides SNS topic generation for forge add sns command.
// It follows functional programming principles with pure generation logic.
package sns

import (
	"context"
	"fmt"
	"strings"

	E "github.com/IBM/fp-go/either"
	"github.com/lewis/forge/internal/generators"
)

// Generator implements generators.Generator for SNS topics
type Generator struct{}

// New creates a new SNS generator
func New() *Generator {
	return &Generator{}
}

// Prompt gathers configuration from user (I/O ACTION)
func (g *Generator) Prompt(ctx context.Context, intent generators.ResourceIntent, state generators.ProjectState) E.Either[error, generators.ResourceConfig] {
	// For MVP, use sensible defaults
	// In Phase 3, this will launch interactive TUI

	config := generators.ResourceConfig{
		Type:   generators.ResourceSNS,
		Name:   intent.Name,
		Module: intent.UseModule,
		Variables: map[string]interface{}{
			"display_name":           intent.Name,
			"fifo_topic":             false,
			"content_based_deduplication": false,
			"kms_master_key_id":      "", // Use default AWS managed key
			"delivery_policy":        "",
			"create_topic_policy":    false,
		},
	}

	// If integrating with Lambda, add integration config
	if intent.ToFunc != "" {
		// Verify target function exists
		if _, exists := state.Functions[intent.ToFunc]; !exists {
			return E.Left[generators.ResourceConfig](
				fmt.Errorf("target function '%s' not found", intent.ToFunc),
			)
		}

		config.Integration = &generators.IntegrationConfig{
			TargetFunction: intent.ToFunc,
			IAMPermissions: []generators.IAMPermission{
				{
					Effect: "Allow",
					Actions: []string{
						"sns:Publish",
					},
					Resources: []string{
						fmt.Sprintf("module.%s.topic_arn", sanitizeName(intent.Name)),
					},
				},
			},
			EnvVars: map[string]string{
				fmt.Sprintf("%s_TOPIC_ARN", strings.ToUpper(sanitizeName(intent.Name))):
					fmt.Sprintf("module.%s.topic_arn", sanitizeName(intent.Name)),
			},
		}
	}

	return E.Right[error](config)
}

// Generate creates Terraform code from configuration (PURE CALCULATION)
func (g *Generator) Generate(config generators.ResourceConfig, state generators.ProjectState) E.Either[error, generators.GeneratedCode] {
	// Validate first, then chain generation - automatic error short-circuiting
	return E.Chain(func(validConfig generators.ResourceConfig) E.Either[error, generators.GeneratedCode] {
		var files []generators.FileToWrite

		// 1. Generate main SNS resource file
		if validConfig.Module {
			files = append(files, generators.FileToWrite{
				Path:    "sns.tf",
				Content: generateModuleCode(validConfig),
				Mode:    generators.WriteModeAppend,
			})
		} else {
			files = append(files, generators.FileToWrite{
				Path:    "sns.tf",
				Content: generateRawResourceCode(validConfig),
				Mode:    generators.WriteModeAppend,
			})
		}

		// 2. Generate outputs
		files = append(files, generators.FileToWrite{
			Path:    "outputs.tf",
			Content: generateOutputs(validConfig),
			Mode:    generators.WriteModeAppend,
		})

		// 3. If integration, update Lambda function file
		if validConfig.Integration != nil {
			lambdaFile := fmt.Sprintf("lambda_%s.tf", validConfig.Integration.TargetFunction)
			files = append(files, generators.FileToWrite{
				Path:    lambdaFile,
				Content: generateIntegrationCode(validConfig),
				Mode:    generators.WriteModeAppend,
			})
		}

		return E.Right[error](generators.GeneratedCode{
			Files: files,
		})
	})(g.Validate(config))
}

// Validate checks if configuration is valid (PURE CALCULATION)
func (g *Generator) Validate(config generators.ResourceConfig) E.Either[error, generators.ResourceConfig] {
	if config.Name == "" {
		return E.Left[generators.ResourceConfig](
			fmt.Errorf("topic name is required"),
		)
	}

	if !isValidName(config.Name) {
		return E.Left[generators.ResourceConfig](
			fmt.Errorf("topic name must be alphanumeric with hyphens/underscores"),
		)
	}

	return E.Right[error](config)
}

// generateModuleCode creates Terraform module code (PURE)
func generateModuleCode(config generators.ResourceConfig) string {
	moduleName := sanitizeName(config.Name)
	topicName := config.Name

	displayName := config.Variables["display_name"].(string)
	fifoTopic := config.Variables["fifo_topic"].(bool)

	var parts []string

	parts = append(parts, "# Generated by forge add sns "+config.Name)
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("module \"%s\" {", moduleName))
	parts = append(parts, "  source  = \"terraform-aws-modules/sns/aws\"")
	parts = append(parts, "  version = \"~> 6.0\"")
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("  name = \"${var.namespace}%s\"", topicName))

	if displayName != "" {
		parts = append(parts, fmt.Sprintf("  display_name = \"%s\"", displayName))
	}

	if fifoTopic {
		parts = append(parts, "")
		parts = append(parts, "  # FIFO topic configuration")
		parts = append(parts, "  fifo_topic                  = true")

		contentBasedDedup, _ := config.Variables["content_based_deduplication"].(bool)
		if contentBasedDedup {
			parts = append(parts, "  content_based_deduplication = true")
		}
	}

	parts = append(parts, "")
	parts = append(parts, "  tags = {")
	parts = append(parts, "    ManagedBy = \"forge\"")
	parts = append(parts, "    Namespace = var.namespace")
	parts = append(parts, "  }")
	parts = append(parts, "}")
	parts = append(parts, "")

	return strings.Join(parts, "\n")
}

// generateRawResourceCode creates raw Terraform resource code (PURE)
func generateRawResourceCode(config generators.ResourceConfig) string {
	resourceName := sanitizeName(config.Name)
	topicName := config.Name

	displayName := config.Variables["display_name"].(string)
	fifoTopic := config.Variables["fifo_topic"].(bool)

	var parts []string

	parts = append(parts, "# Generated by forge add sns "+config.Name+" --raw")
	parts = append(parts, "")
	parts = append(parts, fmt.Sprintf("resource \"aws_sns_topic\" \"%s\" {", resourceName))
	parts = append(parts, fmt.Sprintf("  name = \"${var.namespace}%s\"", topicName))

	if displayName != "" {
		parts = append(parts, fmt.Sprintf("  display_name = \"%s\"", displayName))
	}

	if fifoTopic {
		parts = append(parts, "")
		parts = append(parts, "  fifo_topic = true")

		contentBasedDedup, _ := config.Variables["content_based_deduplication"].(bool)
		if contentBasedDedup {
			parts = append(parts, "  content_based_deduplication = true")
		}
	}

	parts = append(parts, "")
	parts = append(parts, "  tags = {")
	parts = append(parts, "    ManagedBy = \"forge\"")
	parts = append(parts, "    Namespace = var.namespace")
	parts = append(parts, "  }")
	parts = append(parts, "}")
	parts = append(parts, "")

	return strings.Join(parts, "\n")
}

// generateOutputs creates Terraform outputs (PURE)
func generateOutputs(config generators.ResourceConfig) string {
	moduleName := sanitizeName(config.Name)

	var parts []string

	parts = append(parts, "# Outputs for "+config.Name)

	if config.Module {
		parts = append(parts, fmt.Sprintf("output \"%s_topic_arn\" {", moduleName))
		parts = append(parts, fmt.Sprintf("  description = \"ARN of %s\"", config.Name))
		parts = append(parts, fmt.Sprintf("  value       = module.%s.topic_arn", moduleName))
		parts = append(parts, "}")
		parts = append(parts, "")
		parts = append(parts, fmt.Sprintf("output \"%s_topic_id\" {", moduleName))
		parts = append(parts, fmt.Sprintf("  description = \"ID of %s\"", config.Name))
		parts = append(parts, fmt.Sprintf("  value       = module.%s.topic_id", moduleName))
		parts = append(parts, "}")
	} else {
		parts = append(parts, fmt.Sprintf("output \"%s_topic_arn\" {", moduleName))
		parts = append(parts, fmt.Sprintf("  description = \"ARN of %s\"", config.Name))
		parts = append(parts, fmt.Sprintf("  value       = aws_sns_topic.%s.arn", moduleName))
		parts = append(parts, "}")
		parts = append(parts, "")
		parts = append(parts, fmt.Sprintf("output \"%s_topic_id\" {", moduleName))
		parts = append(parts, fmt.Sprintf("  description = \"ID of %s\"", config.Name))
		parts = append(parts, fmt.Sprintf("  value       = aws_sns_topic.%s.id", moduleName))
		parts = append(parts, "}")
	}

	parts = append(parts, "")
	return strings.Join(parts, "\n")
}

// generateIntegrationCode creates Lambda subscription and IAM policy (PURE)
func generateIntegrationCode(config generators.ResourceConfig) string {
	if config.Integration == nil {
		return ""
	}

	topicName := sanitizeName(config.Name)
	functionName := config.Integration.TargetFunction

	var parts []string

	// SNS subscription for Lambda
	parts = append(parts, fmt.Sprintf("# SNS subscription for %s to %s", config.Name, functionName))
	parts = append(parts, fmt.Sprintf("resource \"aws_sns_topic_subscription\" \"%s_%s\" {",
		topicName, functionName))

	if config.Module {
		parts = append(parts, fmt.Sprintf("  topic_arn = module.%s.topic_arn", topicName))
	} else {
		parts = append(parts, fmt.Sprintf("  topic_arn = aws_sns_topic.%s.arn", topicName))
	}

	parts = append(parts, "  protocol  = \"lambda\"")
	parts = append(parts, fmt.Sprintf("  endpoint  = aws_lambda_function.%s.arn", functionName))
	parts = append(parts, "}")
	parts = append(parts, "")

	// Lambda permission for SNS to invoke function
	parts = append(parts, fmt.Sprintf("# Permission for SNS to invoke %s", functionName))
	parts = append(parts, fmt.Sprintf("resource \"aws_lambda_permission\" \"%s_sns_%s\" {",
		functionName, topicName))
	parts = append(parts, "  statement_id  = \"AllowExecutionFromSNS\"")
	parts = append(parts, "  action        = \"lambda:InvokeFunction\"")
	parts = append(parts, fmt.Sprintf("  function_name = aws_lambda_function.%s.function_name", functionName))
	parts = append(parts, "  principal     = \"sns.amazonaws.com\"")

	if config.Module {
		parts = append(parts, fmt.Sprintf("  source_arn    = module.%s.topic_arn", topicName))
	} else {
		parts = append(parts, fmt.Sprintf("  source_arn    = aws_sns_topic.%s.arn", topicName))
	}

	parts = append(parts, "}")
	parts = append(parts, "")

	// IAM policy for Lambda to publish to SNS (if needed)
	if len(config.Integration.IAMPermissions) > 0 {
		perm := config.Integration.IAMPermissions[0]

		parts = append(parts, fmt.Sprintf("# IAM policy for %s to publish to %s", functionName, config.Name))
		parts = append(parts, fmt.Sprintf("resource \"aws_iam_role_policy\" \"%s_sns_%s_publish\" {",
			functionName, topicName))
		parts = append(parts, fmt.Sprintf("  name = \"${var.namespace}%s-sns-%s-publish\"", functionName, topicName))
		parts = append(parts, fmt.Sprintf("  role = aws_iam_role.%s.id", functionName))
		parts = append(parts, "")
		parts = append(parts, "  policy = jsonencode({")
		parts = append(parts, "    Version = \"2012-10-17\"")
		parts = append(parts, "    Statement = [")
		parts = append(parts, "      {")
		parts = append(parts, fmt.Sprintf("        Effect = \"%s\"", perm.Effect))
		parts = append(parts, "        Action = [")

		for i, action := range perm.Actions {
			comma := ","
			if i == len(perm.Actions)-1 {
				comma = ""
			}
			parts = append(parts, fmt.Sprintf("          \"%s\"%s", action, comma))
		}

		parts = append(parts, "        ]")
		parts = append(parts, fmt.Sprintf("        Resource = %s", perm.Resources[0]))
		parts = append(parts, "      }")
		parts = append(parts, "    ]")
		parts = append(parts, "  })}")
		parts = append(parts, "")
	}

	// Environment variables
	if len(config.Integration.EnvVars) > 0 {
		parts = append(parts, fmt.Sprintf("# Note: Add these environment variables to lambda_%s.tf:", functionName))
		for key, value := range config.Integration.EnvVars {
			parts = append(parts, fmt.Sprintf("#   %s = %s", key, value))
		}
		parts = append(parts, "")
	}

	return strings.Join(parts, "\n")
}

// sanitizeName converts a name to a valid Terraform identifier (PURE)
func sanitizeName(name string) string {
	// Replace hyphens with underscores for Terraform identifiers
	return strings.ReplaceAll(name, "-", "_")
}

// isValidName checks if a name is valid (PURE)
func isValidName(name string) bool {
	if len(name) == 0 {
		return false
	}

	for _, r := range name {
		if !((r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') ||
			(r >= '0' && r <= '9') || r == '-' || r == '_') {
			return false
		}
	}

	return true
}
