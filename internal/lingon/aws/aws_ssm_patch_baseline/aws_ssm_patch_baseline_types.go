// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_ssm_patch_baseline

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type ApprovalRule struct {
	// ApproveAfterDays is optional.
	ApproveAfterDays terra.NumberValue `hcl:"approve_after_days,attr"`
	// ApproveUntilDate is optional.
	ApproveUntilDate terra.StringValue `hcl:"approve_until_date,attr"`
	// ComplianceLevel is optional.
	ComplianceLevel terra.StringValue `hcl:"compliance_level,attr"`
	// EnableNonSecurity is optional.
	EnableNonSecurity terra.BoolValue `hcl:"enable_non_security,attr"`
	// ApprovalRulePatchFilter is min=1,max=10.
	PatchFilter []ApprovalRulePatchFilter `hcl:"patch_filter,block" validate:"min=1,max=10"`
}

type ApprovalRulePatchFilter struct {
	// Key is required.
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Values is required.
	Values terra.ListValue[terra.StringValue] `hcl:"values,attr" validate:"required"`
}

type GlobalFilter struct {
	// Key is required.
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Values is required.
	Values terra.ListValue[terra.StringValue] `hcl:"values,attr" validate:"required"`
}

type Source struct {
	// Configuration is required.
	Configuration terra.StringValue `hcl:"configuration,attr" validate:"required"`
	// Name is required.
	Name terra.StringValue `hcl:"name,attr" validate:"required"`
	// Products is required.
	Products terra.ListValue[terra.StringValue] `hcl:"products,attr" validate:"required"`
}

type approvalRuleAttributes struct {
	ref terra.Reference
}

func (ar approvalRuleAttributes) InternalRef() (terra.Reference, error) {
	return ar.ref, nil
}

func (ar approvalRuleAttributes) InternalWithRef(ref terra.Reference) approvalRuleAttributes {
	return approvalRuleAttributes{ref: ref}
}

func (ar approvalRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return ar.ref.InternalTokens()
}

func (ar approvalRuleAttributes) ApproveAfterDays() terra.NumberValue {
	return terra.ReferenceAsNumber(ar.ref.Append("approve_after_days"))
}

func (ar approvalRuleAttributes) ApproveUntilDate() terra.StringValue {
	return terra.ReferenceAsString(ar.ref.Append("approve_until_date"))
}

func (ar approvalRuleAttributes) ComplianceLevel() terra.StringValue {
	return terra.ReferenceAsString(ar.ref.Append("compliance_level"))
}

func (ar approvalRuleAttributes) EnableNonSecurity() terra.BoolValue {
	return terra.ReferenceAsBool(ar.ref.Append("enable_non_security"))
}

func (ar approvalRuleAttributes) PatchFilter() terra.ListValue[approvalRulePatchFilterAttributes] {
	return terra.ReferenceAsList[approvalRulePatchFilterAttributes](ar.ref.Append("patch_filter"))
}

type approvalRulePatchFilterAttributes struct {
	ref terra.Reference
}

func (pf approvalRulePatchFilterAttributes) InternalRef() (terra.Reference, error) {
	return pf.ref, nil
}

func (pf approvalRulePatchFilterAttributes) InternalWithRef(ref terra.Reference) approvalRulePatchFilterAttributes {
	return approvalRulePatchFilterAttributes{ref: ref}
}

func (pf approvalRulePatchFilterAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return pf.ref.InternalTokens()
}

func (pf approvalRulePatchFilterAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(pf.ref.Append("key"))
}

func (pf approvalRulePatchFilterAttributes) Values() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](pf.ref.Append("values"))
}

type globalFilterAttributes struct {
	ref terra.Reference
}

func (gf globalFilterAttributes) InternalRef() (terra.Reference, error) {
	return gf.ref, nil
}

func (gf globalFilterAttributes) InternalWithRef(ref terra.Reference) globalFilterAttributes {
	return globalFilterAttributes{ref: ref}
}

func (gf globalFilterAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return gf.ref.InternalTokens()
}

func (gf globalFilterAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(gf.ref.Append("key"))
}

func (gf globalFilterAttributes) Values() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](gf.ref.Append("values"))
}

type sourceAttributes struct {
	ref terra.Reference
}

func (s sourceAttributes) InternalRef() (terra.Reference, error) {
	return s.ref, nil
}

func (s sourceAttributes) InternalWithRef(ref terra.Reference) sourceAttributes {
	return sourceAttributes{ref: ref}
}

func (s sourceAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return s.ref.InternalTokens()
}

func (s sourceAttributes) Configuration() terra.StringValue {
	return terra.ReferenceAsString(s.ref.Append("configuration"))
}

func (s sourceAttributes) Name() terra.StringValue {
	return terra.ReferenceAsString(s.ref.Append("name"))
}

func (s sourceAttributes) Products() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](s.ref.Append("products"))
}

type ApprovalRuleState struct {
	ApproveAfterDays  float64                        `json:"approve_after_days"`
	ApproveUntilDate  string                         `json:"approve_until_date"`
	ComplianceLevel   string                         `json:"compliance_level"`
	EnableNonSecurity bool                           `json:"enable_non_security"`
	PatchFilter       []ApprovalRulePatchFilterState `json:"patch_filter"`
}

type ApprovalRulePatchFilterState struct {
	Key    string   `json:"key"`
	Values []string `json:"values"`
}

type GlobalFilterState struct {
	Key    string   `json:"key"`
	Values []string `json:"values"`
}

type SourceState struct {
	Configuration string   `json:"configuration"`
	Name          string   `json:"name"`
	Products      []string `json:"products"`
}
