// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_ce_cost_category

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type DataruleAttributes struct {
	ref terra.Reference
}

func (r DataruleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r DataruleAttributes) InternalWithRef(ref terra.Reference) DataruleAttributes {
	return DataruleAttributes{ref: ref}
}

func (r DataruleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r DataruleAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("type"))
}

func (r DataruleAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("value"))
}

func (r DataruleAttributes) InheritedValue() terra.ListValue[DataruleInheritedValueAttributes] {
	return terra.ReferenceAsList[DataruleInheritedValueAttributes](r.ref.Append("inherited_value"))
}

func (r DataruleAttributes) Rule() terra.ListValue[DataruleRuleAttributes] {
	return terra.ReferenceAsList[DataruleRuleAttributes](r.ref.Append("rule"))
}

type DataruleInheritedValueAttributes struct {
	ref terra.Reference
}

func (iv DataruleInheritedValueAttributes) InternalRef() (terra.Reference, error) {
	return iv.ref, nil
}

func (iv DataruleInheritedValueAttributes) InternalWithRef(ref terra.Reference) DataruleInheritedValueAttributes {
	return DataruleInheritedValueAttributes{ref: ref}
}

func (iv DataruleInheritedValueAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return iv.ref.InternalTokens()
}

func (iv DataruleInheritedValueAttributes) DimensionKey() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_key"))
}

func (iv DataruleInheritedValueAttributes) DimensionName() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_name"))
}

type DataruleRuleAttributes struct {
	ref terra.Reference
}

func (r DataruleRuleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r DataruleRuleAttributes) InternalWithRef(ref terra.Reference) DataruleRuleAttributes {
	return DataruleRuleAttributes{ref: ref}
}

func (r DataruleRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r DataruleRuleAttributes) And() terra.SetValue[DataruleRuleAndAttributes] {
	return terra.ReferenceAsSet[DataruleRuleAndAttributes](r.ref.Append("and"))
}

func (r DataruleRuleAttributes) CostCategory() terra.ListValue[DataruleRuleCostCategoryAttributes] {
	return terra.ReferenceAsList[DataruleRuleCostCategoryAttributes](r.ref.Append("cost_category"))
}

func (r DataruleRuleAttributes) Dimension() terra.ListValue[DataruleRuleDimensionAttributes] {
	return terra.ReferenceAsList[DataruleRuleDimensionAttributes](r.ref.Append("dimension"))
}

func (r DataruleRuleAttributes) Not() terra.ListValue[DataruleRuleNotAttributes] {
	return terra.ReferenceAsList[DataruleRuleNotAttributes](r.ref.Append("not"))
}

func (r DataruleRuleAttributes) Or() terra.SetValue[DataruleRuleOrAttributes] {
	return terra.ReferenceAsSet[DataruleRuleOrAttributes](r.ref.Append("or"))
}

func (r DataruleRuleAttributes) Tags() terra.ListValue[DataruleRuleTagsAttributes] {
	return terra.ReferenceAsList[DataruleRuleTagsAttributes](r.ref.Append("tags"))
}

type DataruleRuleAndAttributes struct {
	ref terra.Reference
}

func (a DataruleRuleAndAttributes) InternalRef() (terra.Reference, error) {
	return a.ref, nil
}

func (a DataruleRuleAndAttributes) InternalWithRef(ref terra.Reference) DataruleRuleAndAttributes {
	return DataruleRuleAndAttributes{ref: ref}
}

func (a DataruleRuleAndAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return a.ref.InternalTokens()
}

func (a DataruleRuleAndAttributes) CostCategory() terra.ListValue[DataruleRuleAndCostCategoryAttributes] {
	return terra.ReferenceAsList[DataruleRuleAndCostCategoryAttributes](a.ref.Append("cost_category"))
}

func (a DataruleRuleAndAttributes) Dimension() terra.ListValue[DataruleRuleAndDimensionAttributes] {
	return terra.ReferenceAsList[DataruleRuleAndDimensionAttributes](a.ref.Append("dimension"))
}

func (a DataruleRuleAndAttributes) Tags() terra.ListValue[DataruleRuleAndTagsAttributes] {
	return terra.ReferenceAsList[DataruleRuleAndTagsAttributes](a.ref.Append("tags"))
}

type DataruleRuleAndCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc DataruleRuleAndCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc DataruleRuleAndCostCategoryAttributes) InternalWithRef(ref terra.Reference) DataruleRuleAndCostCategoryAttributes {
	return DataruleRuleAndCostCategoryAttributes{ref: ref}
}

func (cc DataruleRuleAndCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc DataruleRuleAndCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc DataruleRuleAndCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc DataruleRuleAndCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type DataruleRuleAndDimensionAttributes struct {
	ref terra.Reference
}

func (d DataruleRuleAndDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d DataruleRuleAndDimensionAttributes) InternalWithRef(ref terra.Reference) DataruleRuleAndDimensionAttributes {
	return DataruleRuleAndDimensionAttributes{ref: ref}
}

func (d DataruleRuleAndDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d DataruleRuleAndDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d DataruleRuleAndDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d DataruleRuleAndDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type DataruleRuleAndTagsAttributes struct {
	ref terra.Reference
}

func (t DataruleRuleAndTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t DataruleRuleAndTagsAttributes) InternalWithRef(ref terra.Reference) DataruleRuleAndTagsAttributes {
	return DataruleRuleAndTagsAttributes{ref: ref}
}

func (t DataruleRuleAndTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t DataruleRuleAndTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t DataruleRuleAndTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t DataruleRuleAndTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type DataruleRuleCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc DataruleRuleCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc DataruleRuleCostCategoryAttributes) InternalWithRef(ref terra.Reference) DataruleRuleCostCategoryAttributes {
	return DataruleRuleCostCategoryAttributes{ref: ref}
}

func (cc DataruleRuleCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc DataruleRuleCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc DataruleRuleCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc DataruleRuleCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type DataruleRuleDimensionAttributes struct {
	ref terra.Reference
}

func (d DataruleRuleDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d DataruleRuleDimensionAttributes) InternalWithRef(ref terra.Reference) DataruleRuleDimensionAttributes {
	return DataruleRuleDimensionAttributes{ref: ref}
}

func (d DataruleRuleDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d DataruleRuleDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d DataruleRuleDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d DataruleRuleDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type DataruleRuleNotAttributes struct {
	ref terra.Reference
}

func (n DataruleRuleNotAttributes) InternalRef() (terra.Reference, error) {
	return n.ref, nil
}

func (n DataruleRuleNotAttributes) InternalWithRef(ref terra.Reference) DataruleRuleNotAttributes {
	return DataruleRuleNotAttributes{ref: ref}
}

func (n DataruleRuleNotAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return n.ref.InternalTokens()
}

func (n DataruleRuleNotAttributes) CostCategory() terra.ListValue[DataruleRuleNotCostCategoryAttributes] {
	return terra.ReferenceAsList[DataruleRuleNotCostCategoryAttributes](n.ref.Append("cost_category"))
}

func (n DataruleRuleNotAttributes) Dimension() terra.ListValue[DataruleRuleNotDimensionAttributes] {
	return terra.ReferenceAsList[DataruleRuleNotDimensionAttributes](n.ref.Append("dimension"))
}

func (n DataruleRuleNotAttributes) Tags() terra.ListValue[DataruleRuleNotTagsAttributes] {
	return terra.ReferenceAsList[DataruleRuleNotTagsAttributes](n.ref.Append("tags"))
}

type DataruleRuleNotCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc DataruleRuleNotCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc DataruleRuleNotCostCategoryAttributes) InternalWithRef(ref terra.Reference) DataruleRuleNotCostCategoryAttributes {
	return DataruleRuleNotCostCategoryAttributes{ref: ref}
}

func (cc DataruleRuleNotCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc DataruleRuleNotCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc DataruleRuleNotCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc DataruleRuleNotCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type DataruleRuleNotDimensionAttributes struct {
	ref terra.Reference
}

func (d DataruleRuleNotDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d DataruleRuleNotDimensionAttributes) InternalWithRef(ref terra.Reference) DataruleRuleNotDimensionAttributes {
	return DataruleRuleNotDimensionAttributes{ref: ref}
}

func (d DataruleRuleNotDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d DataruleRuleNotDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d DataruleRuleNotDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d DataruleRuleNotDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type DataruleRuleNotTagsAttributes struct {
	ref terra.Reference
}

func (t DataruleRuleNotTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t DataruleRuleNotTagsAttributes) InternalWithRef(ref terra.Reference) DataruleRuleNotTagsAttributes {
	return DataruleRuleNotTagsAttributes{ref: ref}
}

func (t DataruleRuleNotTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t DataruleRuleNotTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t DataruleRuleNotTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t DataruleRuleNotTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type DataruleRuleOrAttributes struct {
	ref terra.Reference
}

func (o DataruleRuleOrAttributes) InternalRef() (terra.Reference, error) {
	return o.ref, nil
}

func (o DataruleRuleOrAttributes) InternalWithRef(ref terra.Reference) DataruleRuleOrAttributes {
	return DataruleRuleOrAttributes{ref: ref}
}

func (o DataruleRuleOrAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return o.ref.InternalTokens()
}

func (o DataruleRuleOrAttributes) CostCategory() terra.ListValue[DataruleRuleOrCostCategoryAttributes] {
	return terra.ReferenceAsList[DataruleRuleOrCostCategoryAttributes](o.ref.Append("cost_category"))
}

func (o DataruleRuleOrAttributes) Dimension() terra.ListValue[DataruleRuleOrDimensionAttributes] {
	return terra.ReferenceAsList[DataruleRuleOrDimensionAttributes](o.ref.Append("dimension"))
}

func (o DataruleRuleOrAttributes) Tags() terra.ListValue[DataruleRuleOrTagsAttributes] {
	return terra.ReferenceAsList[DataruleRuleOrTagsAttributes](o.ref.Append("tags"))
}

type DataruleRuleOrCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc DataruleRuleOrCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc DataruleRuleOrCostCategoryAttributes) InternalWithRef(ref terra.Reference) DataruleRuleOrCostCategoryAttributes {
	return DataruleRuleOrCostCategoryAttributes{ref: ref}
}

func (cc DataruleRuleOrCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc DataruleRuleOrCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc DataruleRuleOrCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc DataruleRuleOrCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type DataruleRuleOrDimensionAttributes struct {
	ref terra.Reference
}

func (d DataruleRuleOrDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d DataruleRuleOrDimensionAttributes) InternalWithRef(ref terra.Reference) DataruleRuleOrDimensionAttributes {
	return DataruleRuleOrDimensionAttributes{ref: ref}
}

func (d DataruleRuleOrDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d DataruleRuleOrDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d DataruleRuleOrDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d DataruleRuleOrDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type DataruleRuleOrTagsAttributes struct {
	ref terra.Reference
}

func (t DataruleRuleOrTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t DataruleRuleOrTagsAttributes) InternalWithRef(ref terra.Reference) DataruleRuleOrTagsAttributes {
	return DataruleRuleOrTagsAttributes{ref: ref}
}

func (t DataruleRuleOrTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t DataruleRuleOrTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t DataruleRuleOrTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t DataruleRuleOrTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type DataruleRuleTagsAttributes struct {
	ref terra.Reference
}

func (t DataruleRuleTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t DataruleRuleTagsAttributes) InternalWithRef(ref terra.Reference) DataruleRuleTagsAttributes {
	return DataruleRuleTagsAttributes{ref: ref}
}

func (t DataruleRuleTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t DataruleRuleTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t DataruleRuleTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t DataruleRuleTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type DatasplitChargeRuleAttributes struct {
	ref terra.Reference
}

func (scr DatasplitChargeRuleAttributes) InternalRef() (terra.Reference, error) {
	return scr.ref, nil
}

func (scr DatasplitChargeRuleAttributes) InternalWithRef(ref terra.Reference) DatasplitChargeRuleAttributes {
	return DatasplitChargeRuleAttributes{ref: ref}
}

func (scr DatasplitChargeRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return scr.ref.InternalTokens()
}

func (scr DatasplitChargeRuleAttributes) Method() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("method"))
}

func (scr DatasplitChargeRuleAttributes) Source() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("source"))
}

func (scr DatasplitChargeRuleAttributes) Targets() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](scr.ref.Append("targets"))
}

func (scr DatasplitChargeRuleAttributes) Parameter() terra.SetValue[DatasplitChargeRuleParameterAttributes] {
	return terra.ReferenceAsSet[DatasplitChargeRuleParameterAttributes](scr.ref.Append("parameter"))
}

type DatasplitChargeRuleParameterAttributes struct {
	ref terra.Reference
}

func (p DatasplitChargeRuleParameterAttributes) InternalRef() (terra.Reference, error) {
	return p.ref, nil
}

func (p DatasplitChargeRuleParameterAttributes) InternalWithRef(ref terra.Reference) DatasplitChargeRuleParameterAttributes {
	return DatasplitChargeRuleParameterAttributes{ref: ref}
}

func (p DatasplitChargeRuleParameterAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return p.ref.InternalTokens()
}

func (p DatasplitChargeRuleParameterAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(p.ref.Append("type"))
}

func (p DatasplitChargeRuleParameterAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](p.ref.Append("values"))
}

type DataRuleState struct {
	Type           string                        `json:"type"`
	Value          string                        `json:"value"`
	InheritedValue []DataRuleInheritedValueState `json:"inherited_value"`
	Rule           []DataRuleRuleState           `json:"rule"`
}

type DataRuleInheritedValueState struct {
	DimensionKey  string `json:"dimension_key"`
	DimensionName string `json:"dimension_name"`
}

type DataRuleRuleState struct {
	And          []DataRuleRuleAndState          `json:"and"`
	CostCategory []DataRuleRuleCostCategoryState `json:"cost_category"`
	Dimension    []DataRuleRuleDimensionState    `json:"dimension"`
	Not          []DataRuleRuleNotState          `json:"not"`
	Or           []DataRuleRuleOrState           `json:"or"`
	Tags         []DataRuleRuleTagsState         `json:"tags"`
}

type DataRuleRuleAndState struct {
	CostCategory []DataRuleRuleAndCostCategoryState `json:"cost_category"`
	Dimension    []DataRuleRuleAndDimensionState    `json:"dimension"`
	Tags         []DataRuleRuleAndTagsState         `json:"tags"`
}

type DataRuleRuleAndCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleAndDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleAndTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleNotState struct {
	CostCategory []DataRuleRuleNotCostCategoryState `json:"cost_category"`
	Dimension    []DataRuleRuleNotDimensionState    `json:"dimension"`
	Tags         []DataRuleRuleNotTagsState         `json:"tags"`
}

type DataRuleRuleNotCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleNotDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleNotTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleOrState struct {
	CostCategory []DataRuleRuleOrCostCategoryState `json:"cost_category"`
	Dimension    []DataRuleRuleOrDimensionState    `json:"dimension"`
	Tags         []DataRuleRuleOrTagsState         `json:"tags"`
}

type DataRuleRuleOrCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleOrDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleOrTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataRuleRuleTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type DataSplitChargeRuleState struct {
	Method    string                              `json:"method"`
	Source    string                              `json:"source"`
	Targets   []string                            `json:"targets"`
	Parameter []DataSplitChargeRuleParameterState `json:"parameter"`
}

type DataSplitChargeRuleParameterState struct {
	Type   string   `json:"type"`
	Values []string `json:"values"`
}
