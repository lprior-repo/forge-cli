// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_ce_cost_category

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type Rule struct {
	// Type is optional.
	Type terra.StringValue `hcl:"type,attr"`
	// Value is optional.
	Value terra.StringValue `hcl:"value,attr"`
	// RuleInheritedValue is optional.
	InheritedValue *RuleInheritedValue `hcl:"inherited_value,block"`
	// RuleRule is optional.
	Rule *RuleRule `hcl:"rule,block"`
}

type RuleInheritedValue struct {
	// DimensionKey is optional.
	DimensionKey terra.StringValue `hcl:"dimension_key,attr"`
	// DimensionName is optional.
	DimensionName terra.StringValue `hcl:"dimension_name,attr"`
}

type RuleRule struct {
	// RuleRuleAnd is min=0.
	And []RuleRuleAnd `hcl:"and,block" validate:"min=0"`
	// RuleRuleCostCategory is optional.
	CostCategory *RuleRuleCostCategory `hcl:"cost_category,block"`
	// RuleRuleDimension is optional.
	Dimension *RuleRuleDimension `hcl:"dimension,block"`
	// RuleRuleNot is optional.
	Not *RuleRuleNot `hcl:"not,block"`
	// RuleRuleOr is min=0.
	Or []RuleRuleOr `hcl:"or,block" validate:"min=0"`
	// RuleRuleTags is optional.
	Tags *RuleRuleTags `hcl:"tags,block"`
}

type RuleRuleAnd struct {
	// RuleRuleAndCostCategory is optional.
	CostCategory *RuleRuleAndCostCategory `hcl:"cost_category,block"`
	// RuleRuleAndDimension is optional.
	Dimension *RuleRuleAndDimension `hcl:"dimension,block"`
	// RuleRuleAndTags is optional.
	Tags *RuleRuleAndTags `hcl:"tags,block"`
}

type RuleRuleAndCostCategory struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleAndDimension struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleAndTags struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleCostCategory struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleDimension struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleNot struct {
	// RuleRuleNotCostCategory is optional.
	CostCategory *RuleRuleNotCostCategory `hcl:"cost_category,block"`
	// RuleRuleNotDimension is optional.
	Dimension *RuleRuleNotDimension `hcl:"dimension,block"`
	// RuleRuleNotTags is optional.
	Tags *RuleRuleNotTags `hcl:"tags,block"`
}

type RuleRuleNotCostCategory struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleNotDimension struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleNotTags struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleOr struct {
	// RuleRuleOrCostCategory is optional.
	CostCategory *RuleRuleOrCostCategory `hcl:"cost_category,block"`
	// RuleRuleOrDimension is optional.
	Dimension *RuleRuleOrDimension `hcl:"dimension,block"`
	// RuleRuleOrTags is optional.
	Tags *RuleRuleOrTags `hcl:"tags,block"`
}

type RuleRuleOrCostCategory struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleOrDimension struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleOrTags struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type RuleRuleTags struct {
	// Key is optional.
	Key terra.StringValue `hcl:"key,attr"`
	// MatchOptions is optional.
	MatchOptions terra.SetValue[terra.StringValue] `hcl:"match_options,attr"`
	// Values is optional.
	Values terra.SetValue[terra.StringValue] `hcl:"values,attr"`
}

type SplitChargeRule struct {
	// Method is required.
	Method terra.StringValue `hcl:"method,attr" validate:"required"`
	// Source is required.
	Source terra.StringValue `hcl:"source,attr" validate:"required"`
	// Targets is required.
	Targets terra.SetValue[terra.StringValue] `hcl:"targets,attr" validate:"required"`
	// SplitChargeRuleParameter is min=0.
	Parameter []SplitChargeRuleParameter `hcl:"parameter,block" validate:"min=0"`
}

type SplitChargeRuleParameter struct {
	// Type is optional.
	Type terra.StringValue `hcl:"type,attr"`
	// Values is optional.
	Values terra.ListValue[terra.StringValue] `hcl:"values,attr"`
}

type ruleAttributes struct {
	ref terra.Reference
}

func (r ruleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r ruleAttributes) InternalWithRef(ref terra.Reference) ruleAttributes {
	return ruleAttributes{ref: ref}
}

func (r ruleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r ruleAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("type"))
}

func (r ruleAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(r.ref.Append("value"))
}

func (r ruleAttributes) InheritedValue() terra.ListValue[ruleInheritedValueAttributes] {
	return terra.ReferenceAsList[ruleInheritedValueAttributes](r.ref.Append("inherited_value"))
}

func (r ruleAttributes) Rule() terra.ListValue[ruleRuleAttributes] {
	return terra.ReferenceAsList[ruleRuleAttributes](r.ref.Append("rule"))
}

type ruleInheritedValueAttributes struct {
	ref terra.Reference
}

func (iv ruleInheritedValueAttributes) InternalRef() (terra.Reference, error) {
	return iv.ref, nil
}

func (iv ruleInheritedValueAttributes) InternalWithRef(ref terra.Reference) ruleInheritedValueAttributes {
	return ruleInheritedValueAttributes{ref: ref}
}

func (iv ruleInheritedValueAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return iv.ref.InternalTokens()
}

func (iv ruleInheritedValueAttributes) DimensionKey() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_key"))
}

func (iv ruleInheritedValueAttributes) DimensionName() terra.StringValue {
	return terra.ReferenceAsString(iv.ref.Append("dimension_name"))
}

type ruleRuleAttributes struct {
	ref terra.Reference
}

func (r ruleRuleAttributes) InternalRef() (terra.Reference, error) {
	return r.ref, nil
}

func (r ruleRuleAttributes) InternalWithRef(ref terra.Reference) ruleRuleAttributes {
	return ruleRuleAttributes{ref: ref}
}

func (r ruleRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return r.ref.InternalTokens()
}

func (r ruleRuleAttributes) And() terra.SetValue[ruleRuleAndAttributes] {
	return terra.ReferenceAsSet[ruleRuleAndAttributes](r.ref.Append("and"))
}

func (r ruleRuleAttributes) CostCategory() terra.ListValue[ruleRuleCostCategoryAttributes] {
	return terra.ReferenceAsList[ruleRuleCostCategoryAttributes](r.ref.Append("cost_category"))
}

func (r ruleRuleAttributes) Dimension() terra.ListValue[ruleRuleDimensionAttributes] {
	return terra.ReferenceAsList[ruleRuleDimensionAttributes](r.ref.Append("dimension"))
}

func (r ruleRuleAttributes) Not() terra.ListValue[ruleRuleNotAttributes] {
	return terra.ReferenceAsList[ruleRuleNotAttributes](r.ref.Append("not"))
}

func (r ruleRuleAttributes) Or() terra.SetValue[ruleRuleOrAttributes] {
	return terra.ReferenceAsSet[ruleRuleOrAttributes](r.ref.Append("or"))
}

func (r ruleRuleAttributes) Tags() terra.ListValue[ruleRuleTagsAttributes] {
	return terra.ReferenceAsList[ruleRuleTagsAttributes](r.ref.Append("tags"))
}

type ruleRuleAndAttributes struct {
	ref terra.Reference
}

func (a ruleRuleAndAttributes) InternalRef() (terra.Reference, error) {
	return a.ref, nil
}

func (a ruleRuleAndAttributes) InternalWithRef(ref terra.Reference) ruleRuleAndAttributes {
	return ruleRuleAndAttributes{ref: ref}
}

func (a ruleRuleAndAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return a.ref.InternalTokens()
}

func (a ruleRuleAndAttributes) CostCategory() terra.ListValue[ruleRuleAndCostCategoryAttributes] {
	return terra.ReferenceAsList[ruleRuleAndCostCategoryAttributes](a.ref.Append("cost_category"))
}

func (a ruleRuleAndAttributes) Dimension() terra.ListValue[ruleRuleAndDimensionAttributes] {
	return terra.ReferenceAsList[ruleRuleAndDimensionAttributes](a.ref.Append("dimension"))
}

func (a ruleRuleAndAttributes) Tags() terra.ListValue[ruleRuleAndTagsAttributes] {
	return terra.ReferenceAsList[ruleRuleAndTagsAttributes](a.ref.Append("tags"))
}

type ruleRuleAndCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc ruleRuleAndCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc ruleRuleAndCostCategoryAttributes) InternalWithRef(ref terra.Reference) ruleRuleAndCostCategoryAttributes {
	return ruleRuleAndCostCategoryAttributes{ref: ref}
}

func (cc ruleRuleAndCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc ruleRuleAndCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc ruleRuleAndCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc ruleRuleAndCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type ruleRuleAndDimensionAttributes struct {
	ref terra.Reference
}

func (d ruleRuleAndDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d ruleRuleAndDimensionAttributes) InternalWithRef(ref terra.Reference) ruleRuleAndDimensionAttributes {
	return ruleRuleAndDimensionAttributes{ref: ref}
}

func (d ruleRuleAndDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d ruleRuleAndDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d ruleRuleAndDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d ruleRuleAndDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type ruleRuleAndTagsAttributes struct {
	ref terra.Reference
}

func (t ruleRuleAndTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t ruleRuleAndTagsAttributes) InternalWithRef(ref terra.Reference) ruleRuleAndTagsAttributes {
	return ruleRuleAndTagsAttributes{ref: ref}
}

func (t ruleRuleAndTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t ruleRuleAndTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t ruleRuleAndTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t ruleRuleAndTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type ruleRuleCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc ruleRuleCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc ruleRuleCostCategoryAttributes) InternalWithRef(ref terra.Reference) ruleRuleCostCategoryAttributes {
	return ruleRuleCostCategoryAttributes{ref: ref}
}

func (cc ruleRuleCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc ruleRuleCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc ruleRuleCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc ruleRuleCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type ruleRuleDimensionAttributes struct {
	ref terra.Reference
}

func (d ruleRuleDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d ruleRuleDimensionAttributes) InternalWithRef(ref terra.Reference) ruleRuleDimensionAttributes {
	return ruleRuleDimensionAttributes{ref: ref}
}

func (d ruleRuleDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d ruleRuleDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d ruleRuleDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d ruleRuleDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type ruleRuleNotAttributes struct {
	ref terra.Reference
}

func (n ruleRuleNotAttributes) InternalRef() (terra.Reference, error) {
	return n.ref, nil
}

func (n ruleRuleNotAttributes) InternalWithRef(ref terra.Reference) ruleRuleNotAttributes {
	return ruleRuleNotAttributes{ref: ref}
}

func (n ruleRuleNotAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return n.ref.InternalTokens()
}

func (n ruleRuleNotAttributes) CostCategory() terra.ListValue[ruleRuleNotCostCategoryAttributes] {
	return terra.ReferenceAsList[ruleRuleNotCostCategoryAttributes](n.ref.Append("cost_category"))
}

func (n ruleRuleNotAttributes) Dimension() terra.ListValue[ruleRuleNotDimensionAttributes] {
	return terra.ReferenceAsList[ruleRuleNotDimensionAttributes](n.ref.Append("dimension"))
}

func (n ruleRuleNotAttributes) Tags() terra.ListValue[ruleRuleNotTagsAttributes] {
	return terra.ReferenceAsList[ruleRuleNotTagsAttributes](n.ref.Append("tags"))
}

type ruleRuleNotCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc ruleRuleNotCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc ruleRuleNotCostCategoryAttributes) InternalWithRef(ref terra.Reference) ruleRuleNotCostCategoryAttributes {
	return ruleRuleNotCostCategoryAttributes{ref: ref}
}

func (cc ruleRuleNotCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc ruleRuleNotCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc ruleRuleNotCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc ruleRuleNotCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type ruleRuleNotDimensionAttributes struct {
	ref terra.Reference
}

func (d ruleRuleNotDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d ruleRuleNotDimensionAttributes) InternalWithRef(ref terra.Reference) ruleRuleNotDimensionAttributes {
	return ruleRuleNotDimensionAttributes{ref: ref}
}

func (d ruleRuleNotDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d ruleRuleNotDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d ruleRuleNotDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d ruleRuleNotDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type ruleRuleNotTagsAttributes struct {
	ref terra.Reference
}

func (t ruleRuleNotTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t ruleRuleNotTagsAttributes) InternalWithRef(ref terra.Reference) ruleRuleNotTagsAttributes {
	return ruleRuleNotTagsAttributes{ref: ref}
}

func (t ruleRuleNotTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t ruleRuleNotTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t ruleRuleNotTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t ruleRuleNotTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type ruleRuleOrAttributes struct {
	ref terra.Reference
}

func (o ruleRuleOrAttributes) InternalRef() (terra.Reference, error) {
	return o.ref, nil
}

func (o ruleRuleOrAttributes) InternalWithRef(ref terra.Reference) ruleRuleOrAttributes {
	return ruleRuleOrAttributes{ref: ref}
}

func (o ruleRuleOrAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return o.ref.InternalTokens()
}

func (o ruleRuleOrAttributes) CostCategory() terra.ListValue[ruleRuleOrCostCategoryAttributes] {
	return terra.ReferenceAsList[ruleRuleOrCostCategoryAttributes](o.ref.Append("cost_category"))
}

func (o ruleRuleOrAttributes) Dimension() terra.ListValue[ruleRuleOrDimensionAttributes] {
	return terra.ReferenceAsList[ruleRuleOrDimensionAttributes](o.ref.Append("dimension"))
}

func (o ruleRuleOrAttributes) Tags() terra.ListValue[ruleRuleOrTagsAttributes] {
	return terra.ReferenceAsList[ruleRuleOrTagsAttributes](o.ref.Append("tags"))
}

type ruleRuleOrCostCategoryAttributes struct {
	ref terra.Reference
}

func (cc ruleRuleOrCostCategoryAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc ruleRuleOrCostCategoryAttributes) InternalWithRef(ref terra.Reference) ruleRuleOrCostCategoryAttributes {
	return ruleRuleOrCostCategoryAttributes{ref: ref}
}

func (cc ruleRuleOrCostCategoryAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc ruleRuleOrCostCategoryAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("key"))
}

func (cc ruleRuleOrCostCategoryAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("match_options"))
}

func (cc ruleRuleOrCostCategoryAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](cc.ref.Append("values"))
}

type ruleRuleOrDimensionAttributes struct {
	ref terra.Reference
}

func (d ruleRuleOrDimensionAttributes) InternalRef() (terra.Reference, error) {
	return d.ref, nil
}

func (d ruleRuleOrDimensionAttributes) InternalWithRef(ref terra.Reference) ruleRuleOrDimensionAttributes {
	return ruleRuleOrDimensionAttributes{ref: ref}
}

func (d ruleRuleOrDimensionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return d.ref.InternalTokens()
}

func (d ruleRuleOrDimensionAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(d.ref.Append("key"))
}

func (d ruleRuleOrDimensionAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("match_options"))
}

func (d ruleRuleOrDimensionAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](d.ref.Append("values"))
}

type ruleRuleOrTagsAttributes struct {
	ref terra.Reference
}

func (t ruleRuleOrTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t ruleRuleOrTagsAttributes) InternalWithRef(ref terra.Reference) ruleRuleOrTagsAttributes {
	return ruleRuleOrTagsAttributes{ref: ref}
}

func (t ruleRuleOrTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t ruleRuleOrTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t ruleRuleOrTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t ruleRuleOrTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type ruleRuleTagsAttributes struct {
	ref terra.Reference
}

func (t ruleRuleTagsAttributes) InternalRef() (terra.Reference, error) {
	return t.ref, nil
}

func (t ruleRuleTagsAttributes) InternalWithRef(ref terra.Reference) ruleRuleTagsAttributes {
	return ruleRuleTagsAttributes{ref: ref}
}

func (t ruleRuleTagsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return t.ref.InternalTokens()
}

func (t ruleRuleTagsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(t.ref.Append("key"))
}

func (t ruleRuleTagsAttributes) MatchOptions() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("match_options"))
}

func (t ruleRuleTagsAttributes) Values() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](t.ref.Append("values"))
}

type splitChargeRuleAttributes struct {
	ref terra.Reference
}

func (scr splitChargeRuleAttributes) InternalRef() (terra.Reference, error) {
	return scr.ref, nil
}

func (scr splitChargeRuleAttributes) InternalWithRef(ref terra.Reference) splitChargeRuleAttributes {
	return splitChargeRuleAttributes{ref: ref}
}

func (scr splitChargeRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return scr.ref.InternalTokens()
}

func (scr splitChargeRuleAttributes) Method() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("method"))
}

func (scr splitChargeRuleAttributes) Source() terra.StringValue {
	return terra.ReferenceAsString(scr.ref.Append("source"))
}

func (scr splitChargeRuleAttributes) Targets() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](scr.ref.Append("targets"))
}

func (scr splitChargeRuleAttributes) Parameter() terra.SetValue[splitChargeRuleParameterAttributes] {
	return terra.ReferenceAsSet[splitChargeRuleParameterAttributes](scr.ref.Append("parameter"))
}

type splitChargeRuleParameterAttributes struct {
	ref terra.Reference
}

func (p splitChargeRuleParameterAttributes) InternalRef() (terra.Reference, error) {
	return p.ref, nil
}

func (p splitChargeRuleParameterAttributes) InternalWithRef(ref terra.Reference) splitChargeRuleParameterAttributes {
	return splitChargeRuleParameterAttributes{ref: ref}
}

func (p splitChargeRuleParameterAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return p.ref.InternalTokens()
}

func (p splitChargeRuleParameterAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(p.ref.Append("type"))
}

func (p splitChargeRuleParameterAttributes) Values() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](p.ref.Append("values"))
}

type RuleState struct {
	Type           string                    `json:"type"`
	Value          string                    `json:"value"`
	InheritedValue []RuleInheritedValueState `json:"inherited_value"`
	Rule           []RuleRuleState           `json:"rule"`
}

type RuleInheritedValueState struct {
	DimensionKey  string `json:"dimension_key"`
	DimensionName string `json:"dimension_name"`
}

type RuleRuleState struct {
	And          []RuleRuleAndState          `json:"and"`
	CostCategory []RuleRuleCostCategoryState `json:"cost_category"`
	Dimension    []RuleRuleDimensionState    `json:"dimension"`
	Not          []RuleRuleNotState          `json:"not"`
	Or           []RuleRuleOrState           `json:"or"`
	Tags         []RuleRuleTagsState         `json:"tags"`
}

type RuleRuleAndState struct {
	CostCategory []RuleRuleAndCostCategoryState `json:"cost_category"`
	Dimension    []RuleRuleAndDimensionState    `json:"dimension"`
	Tags         []RuleRuleAndTagsState         `json:"tags"`
}

type RuleRuleAndCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleAndDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleAndTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleNotState struct {
	CostCategory []RuleRuleNotCostCategoryState `json:"cost_category"`
	Dimension    []RuleRuleNotDimensionState    `json:"dimension"`
	Tags         []RuleRuleNotTagsState         `json:"tags"`
}

type RuleRuleNotCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleNotDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleNotTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleOrState struct {
	CostCategory []RuleRuleOrCostCategoryState `json:"cost_category"`
	Dimension    []RuleRuleOrDimensionState    `json:"dimension"`
	Tags         []RuleRuleOrTagsState         `json:"tags"`
}

type RuleRuleOrCostCategoryState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleOrDimensionState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleOrTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type RuleRuleTagsState struct {
	Key          string   `json:"key"`
	MatchOptions []string `json:"match_options"`
	Values       []string `json:"values"`
}

type SplitChargeRuleState struct {
	Method    string                          `json:"method"`
	Source    string                          `json:"source"`
	Targets   []string                        `json:"targets"`
	Parameter []SplitChargeRuleParameterState `json:"parameter"`
}

type SplitChargeRuleParameterState struct {
	Type   string   `json:"type"`
	Values []string `json:"values"`
}
