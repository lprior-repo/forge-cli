// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_macie2_findings_filter

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type FindingCriteria struct {
	// FindingCriteriaCriterion is min=0.
	Criterion []FindingCriteriaCriterion `hcl:"criterion,block" validate:"min=0"`
}

type FindingCriteriaCriterion struct {
	// Eq is optional.
	Eq terra.SetValue[terra.StringValue] `hcl:"eq,attr"`
	// EqExactMatch is optional.
	EqExactMatch terra.SetValue[terra.StringValue] `hcl:"eq_exact_match,attr"`
	// Field is required.
	Field terra.StringValue `hcl:"field,attr" validate:"required"`
	// Gt is optional.
	Gt terra.StringValue `hcl:"gt,attr"`
	// Gte is optional.
	Gte terra.StringValue `hcl:"gte,attr"`
	// Lt is optional.
	Lt terra.StringValue `hcl:"lt,attr"`
	// Lte is optional.
	Lte terra.StringValue `hcl:"lte,attr"`
	// Neq is optional.
	Neq terra.SetValue[terra.StringValue] `hcl:"neq,attr"`
}

type findingCriteriaAttributes struct {
	ref terra.Reference
}

func (fc findingCriteriaAttributes) InternalRef() (terra.Reference, error) {
	return fc.ref, nil
}

func (fc findingCriteriaAttributes) InternalWithRef(ref terra.Reference) findingCriteriaAttributes {
	return findingCriteriaAttributes{ref: ref}
}

func (fc findingCriteriaAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return fc.ref.InternalTokens()
}

func (fc findingCriteriaAttributes) Criterion() terra.SetValue[findingCriteriaCriterionAttributes] {
	return terra.ReferenceAsSet[findingCriteriaCriterionAttributes](fc.ref.Append("criterion"))
}

type findingCriteriaCriterionAttributes struct {
	ref terra.Reference
}

func (c findingCriteriaCriterionAttributes) InternalRef() (terra.Reference, error) {
	return c.ref, nil
}

func (c findingCriteriaCriterionAttributes) InternalWithRef(ref terra.Reference) findingCriteriaCriterionAttributes {
	return findingCriteriaCriterionAttributes{ref: ref}
}

func (c findingCriteriaCriterionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return c.ref.InternalTokens()
}

func (c findingCriteriaCriterionAttributes) Eq() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](c.ref.Append("eq"))
}

func (c findingCriteriaCriterionAttributes) EqExactMatch() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](c.ref.Append("eq_exact_match"))
}

func (c findingCriteriaCriterionAttributes) Field() terra.StringValue {
	return terra.ReferenceAsString(c.ref.Append("field"))
}

func (c findingCriteriaCriterionAttributes) Gt() terra.StringValue {
	return terra.ReferenceAsString(c.ref.Append("gt"))
}

func (c findingCriteriaCriterionAttributes) Gte() terra.StringValue {
	return terra.ReferenceAsString(c.ref.Append("gte"))
}

func (c findingCriteriaCriterionAttributes) Lt() terra.StringValue {
	return terra.ReferenceAsString(c.ref.Append("lt"))
}

func (c findingCriteriaCriterionAttributes) Lte() terra.StringValue {
	return terra.ReferenceAsString(c.ref.Append("lte"))
}

func (c findingCriteriaCriterionAttributes) Neq() terra.SetValue[terra.StringValue] {
	return terra.ReferenceAsSet[terra.StringValue](c.ref.Append("neq"))
}

type FindingCriteriaState struct {
	Criterion []FindingCriteriaCriterionState `json:"criterion"`
}

type FindingCriteriaCriterionState struct {
	Eq           []string `json:"eq"`
	EqExactMatch []string `json:"eq_exact_match"`
	Field        string   `json:"field"`
	Gt           string   `json:"gt"`
	Gte          string   `json:"gte"`
	Lt           string   `json:"lt"`
	Lte          string   `json:"lte"`
	Neq          []string `json:"neq"`
}
