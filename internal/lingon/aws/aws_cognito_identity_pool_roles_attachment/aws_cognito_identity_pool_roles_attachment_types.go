// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_cognito_identity_pool_roles_attachment

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type RoleMapping struct {
	// AmbiguousRoleResolution is optional.
	AmbiguousRoleResolution terra.StringValue `hcl:"ambiguous_role_resolution,attr"`
	// IdentityProvider is required.
	IdentityProvider terra.StringValue `hcl:"identity_provider,attr" validate:"required"`
	// Type is required.
	Type terra.StringValue `hcl:"type,attr" validate:"required"`
	// RoleMappingMappingRule is min=0,max=25.
	MappingRule []RoleMappingMappingRule `hcl:"mapping_rule,block" validate:"min=0,max=25"`
}

type RoleMappingMappingRule struct {
	// Claim is required.
	Claim terra.StringValue `hcl:"claim,attr" validate:"required"`
	// MatchType is required.
	MatchType terra.StringValue `hcl:"match_type,attr" validate:"required"`
	// RoleArn is required.
	RoleArn terra.StringValue `hcl:"role_arn,attr" validate:"required"`
	// Value is required.
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type roleMappingAttributes struct {
	ref terra.Reference
}

func (rm roleMappingAttributes) InternalRef() (terra.Reference, error) {
	return rm.ref, nil
}

func (rm roleMappingAttributes) InternalWithRef(ref terra.Reference) roleMappingAttributes {
	return roleMappingAttributes{ref: ref}
}

func (rm roleMappingAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return rm.ref.InternalTokens()
}

func (rm roleMappingAttributes) AmbiguousRoleResolution() terra.StringValue {
	return terra.ReferenceAsString(rm.ref.Append("ambiguous_role_resolution"))
}

func (rm roleMappingAttributes) IdentityProvider() terra.StringValue {
	return terra.ReferenceAsString(rm.ref.Append("identity_provider"))
}

func (rm roleMappingAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(rm.ref.Append("type"))
}

func (rm roleMappingAttributes) MappingRule() terra.ListValue[roleMappingMappingRuleAttributes] {
	return terra.ReferenceAsList[roleMappingMappingRuleAttributes](rm.ref.Append("mapping_rule"))
}

type roleMappingMappingRuleAttributes struct {
	ref terra.Reference
}

func (mr roleMappingMappingRuleAttributes) InternalRef() (terra.Reference, error) {
	return mr.ref, nil
}

func (mr roleMappingMappingRuleAttributes) InternalWithRef(ref terra.Reference) roleMappingMappingRuleAttributes {
	return roleMappingMappingRuleAttributes{ref: ref}
}

func (mr roleMappingMappingRuleAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return mr.ref.InternalTokens()
}

func (mr roleMappingMappingRuleAttributes) Claim() terra.StringValue {
	return terra.ReferenceAsString(mr.ref.Append("claim"))
}

func (mr roleMappingMappingRuleAttributes) MatchType() terra.StringValue {
	return terra.ReferenceAsString(mr.ref.Append("match_type"))
}

func (mr roleMappingMappingRuleAttributes) RoleArn() terra.StringValue {
	return terra.ReferenceAsString(mr.ref.Append("role_arn"))
}

func (mr roleMappingMappingRuleAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(mr.ref.Append("value"))
}

type RoleMappingState struct {
	AmbiguousRoleResolution string                        `json:"ambiguous_role_resolution"`
	IdentityProvider        string                        `json:"identity_provider"`
	Type                    string                        `json:"type"`
	MappingRule             []RoleMappingMappingRuleState `json:"mapping_rule"`
}

type RoleMappingMappingRuleState struct {
	Claim     string `json:"claim"`
	MatchType string `json:"match_type"`
	RoleArn   string `json:"role_arn"`
	Value     string `json:"value"`
}
