// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_accessanalyzer_archive_rule

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type Filter struct {
	// Contains is optional.
	Contains terra.ListValue[terra.StringValue] `hcl:"contains,attr"`
	// Criteria is required.
	Criteria terra.StringValue `hcl:"criteria,attr" validate:"required"`
	// Eq is optional.
	Eq terra.ListValue[terra.StringValue] `hcl:"eq,attr"`
	// Exists is optional.
	Exists terra.StringValue `hcl:"exists,attr"`
	// Neq is optional.
	Neq terra.ListValue[terra.StringValue] `hcl:"neq,attr"`
}

type filterAttributes struct {
	ref terra.Reference
}

func (f filterAttributes) InternalRef() (terra.Reference, error) {
	return f.ref, nil
}

func (f filterAttributes) InternalWithRef(ref terra.Reference) filterAttributes {
	return filterAttributes{ref: ref}
}

func (f filterAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return f.ref.InternalTokens()
}

func (f filterAttributes) Contains() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](f.ref.Append("contains"))
}

func (f filterAttributes) Criteria() terra.StringValue {
	return terra.ReferenceAsString(f.ref.Append("criteria"))
}

func (f filterAttributes) Eq() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](f.ref.Append("eq"))
}

func (f filterAttributes) Exists() terra.StringValue {
	return terra.ReferenceAsString(f.ref.Append("exists"))
}

func (f filterAttributes) Neq() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](f.ref.Append("neq"))
}

type FilterState struct {
	Contains []string `json:"contains"`
	Criteria string   `json:"criteria"`
	Eq       []string `json:"eq"`
	Exists   string   `json:"exists"`
	Neq      []string `json:"neq"`
}
