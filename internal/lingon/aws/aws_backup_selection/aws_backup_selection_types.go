// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_backup_selection

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type Condition struct {
	// ConditionStringEquals is min=0.
	StringEquals []ConditionStringEquals `hcl:"string_equals,block" validate:"min=0"`
	// ConditionStringLike is min=0.
	StringLike []ConditionStringLike `hcl:"string_like,block" validate:"min=0"`
	// ConditionStringNotEquals is min=0.
	StringNotEquals []ConditionStringNotEquals `hcl:"string_not_equals,block" validate:"min=0"`
	// ConditionStringNotLike is min=0.
	StringNotLike []ConditionStringNotLike `hcl:"string_not_like,block" validate:"min=0"`
}

type ConditionStringEquals struct {
	// Key is required.
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Value is required.
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type ConditionStringLike struct {
	// Key is required.
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Value is required.
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type ConditionStringNotEquals struct {
	// Key is required.
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Value is required.
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type ConditionStringNotLike struct {
	// Key is required.
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Value is required.
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type SelectionTag struct {
	// Key is required.
	Key terra.StringValue `hcl:"key,attr" validate:"required"`
	// Type is required.
	Type terra.StringValue `hcl:"type,attr" validate:"required"`
	// Value is required.
	Value terra.StringValue `hcl:"value,attr" validate:"required"`
}

type conditionAttributes struct {
	ref terra.Reference
}

func (c conditionAttributes) InternalRef() (terra.Reference, error) {
	return c.ref, nil
}

func (c conditionAttributes) InternalWithRef(ref terra.Reference) conditionAttributes {
	return conditionAttributes{ref: ref}
}

func (c conditionAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return c.ref.InternalTokens()
}

func (c conditionAttributes) StringEquals() terra.SetValue[conditionStringEqualsAttributes] {
	return terra.ReferenceAsSet[conditionStringEqualsAttributes](c.ref.Append("string_equals"))
}

func (c conditionAttributes) StringLike() terra.SetValue[conditionStringLikeAttributes] {
	return terra.ReferenceAsSet[conditionStringLikeAttributes](c.ref.Append("string_like"))
}

func (c conditionAttributes) StringNotEquals() terra.SetValue[conditionStringNotEqualsAttributes] {
	return terra.ReferenceAsSet[conditionStringNotEqualsAttributes](c.ref.Append("string_not_equals"))
}

func (c conditionAttributes) StringNotLike() terra.SetValue[conditionStringNotLikeAttributes] {
	return terra.ReferenceAsSet[conditionStringNotLikeAttributes](c.ref.Append("string_not_like"))
}

type conditionStringEqualsAttributes struct {
	ref terra.Reference
}

func (se conditionStringEqualsAttributes) InternalRef() (terra.Reference, error) {
	return se.ref, nil
}

func (se conditionStringEqualsAttributes) InternalWithRef(ref terra.Reference) conditionStringEqualsAttributes {
	return conditionStringEqualsAttributes{ref: ref}
}

func (se conditionStringEqualsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return se.ref.InternalTokens()
}

func (se conditionStringEqualsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("key"))
}

func (se conditionStringEqualsAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(se.ref.Append("value"))
}

type conditionStringLikeAttributes struct {
	ref terra.Reference
}

func (sl conditionStringLikeAttributes) InternalRef() (terra.Reference, error) {
	return sl.ref, nil
}

func (sl conditionStringLikeAttributes) InternalWithRef(ref terra.Reference) conditionStringLikeAttributes {
	return conditionStringLikeAttributes{ref: ref}
}

func (sl conditionStringLikeAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return sl.ref.InternalTokens()
}

func (sl conditionStringLikeAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(sl.ref.Append("key"))
}

func (sl conditionStringLikeAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(sl.ref.Append("value"))
}

type conditionStringNotEqualsAttributes struct {
	ref terra.Reference
}

func (sne conditionStringNotEqualsAttributes) InternalRef() (terra.Reference, error) {
	return sne.ref, nil
}

func (sne conditionStringNotEqualsAttributes) InternalWithRef(ref terra.Reference) conditionStringNotEqualsAttributes {
	return conditionStringNotEqualsAttributes{ref: ref}
}

func (sne conditionStringNotEqualsAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return sne.ref.InternalTokens()
}

func (sne conditionStringNotEqualsAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(sne.ref.Append("key"))
}

func (sne conditionStringNotEqualsAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(sne.ref.Append("value"))
}

type conditionStringNotLikeAttributes struct {
	ref terra.Reference
}

func (snl conditionStringNotLikeAttributes) InternalRef() (terra.Reference, error) {
	return snl.ref, nil
}

func (snl conditionStringNotLikeAttributes) InternalWithRef(ref terra.Reference) conditionStringNotLikeAttributes {
	return conditionStringNotLikeAttributes{ref: ref}
}

func (snl conditionStringNotLikeAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return snl.ref.InternalTokens()
}

func (snl conditionStringNotLikeAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(snl.ref.Append("key"))
}

func (snl conditionStringNotLikeAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(snl.ref.Append("value"))
}

type selectionTagAttributes struct {
	ref terra.Reference
}

func (st selectionTagAttributes) InternalRef() (terra.Reference, error) {
	return st.ref, nil
}

func (st selectionTagAttributes) InternalWithRef(ref terra.Reference) selectionTagAttributes {
	return selectionTagAttributes{ref: ref}
}

func (st selectionTagAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return st.ref.InternalTokens()
}

func (st selectionTagAttributes) Key() terra.StringValue {
	return terra.ReferenceAsString(st.ref.Append("key"))
}

func (st selectionTagAttributes) Type() terra.StringValue {
	return terra.ReferenceAsString(st.ref.Append("type"))
}

func (st selectionTagAttributes) Value() terra.StringValue {
	return terra.ReferenceAsString(st.ref.Append("value"))
}

type ConditionState struct {
	StringEquals    []ConditionStringEqualsState    `json:"string_equals"`
	StringLike      []ConditionStringLikeState      `json:"string_like"`
	StringNotEquals []ConditionStringNotEqualsState `json:"string_not_equals"`
	StringNotLike   []ConditionStringNotLikeState   `json:"string_not_like"`
}

type ConditionStringEqualsState struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type ConditionStringLikeState struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type ConditionStringNotEqualsState struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type ConditionStringNotLikeState struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type SelectionTagState struct {
	Key   string `json:"key"`
	Type  string `json:"type"`
	Value string `json:"value"`
}
