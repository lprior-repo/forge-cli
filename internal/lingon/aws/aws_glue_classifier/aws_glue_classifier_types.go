// CODE GENERATED BY github.com/golingon/lingon. DO NOT EDIT.

package aws_glue_classifier

import (
	terra "github.com/golingon/lingon/pkg/terra"
	hclwrite "github.com/hashicorp/hcl/v2/hclwrite"
)

type CsvClassifier struct {
	// AllowSingleColumn is optional.
	AllowSingleColumn terra.BoolValue `hcl:"allow_single_column,attr"`
	// ContainsHeader is optional.
	ContainsHeader terra.StringValue `hcl:"contains_header,attr"`
	// CustomDatatypeConfigured is optional.
	CustomDatatypeConfigured terra.BoolValue `hcl:"custom_datatype_configured,attr"`
	// CustomDatatypes is optional.
	CustomDatatypes terra.ListValue[terra.StringValue] `hcl:"custom_datatypes,attr"`
	// Delimiter is optional.
	Delimiter terra.StringValue `hcl:"delimiter,attr"`
	// DisableValueTrimming is optional.
	DisableValueTrimming terra.BoolValue `hcl:"disable_value_trimming,attr"`
	// Header is optional.
	Header terra.ListValue[terra.StringValue] `hcl:"header,attr"`
	// QuoteSymbol is optional.
	QuoteSymbol terra.StringValue `hcl:"quote_symbol,attr"`
}

type GrokClassifier struct {
	// Classification is required.
	Classification terra.StringValue `hcl:"classification,attr" validate:"required"`
	// CustomPatterns is optional.
	CustomPatterns terra.StringValue `hcl:"custom_patterns,attr"`
	// GrokPattern is required.
	GrokPattern terra.StringValue `hcl:"grok_pattern,attr" validate:"required"`
}

type JsonClassifier struct {
	// JsonPath is required.
	JsonPath terra.StringValue `hcl:"json_path,attr" validate:"required"`
}

type XmlClassifier struct {
	// Classification is required.
	Classification terra.StringValue `hcl:"classification,attr" validate:"required"`
	// RowTag is required.
	RowTag terra.StringValue `hcl:"row_tag,attr" validate:"required"`
}

type csvClassifierAttributes struct {
	ref terra.Reference
}

func (cc csvClassifierAttributes) InternalRef() (terra.Reference, error) {
	return cc.ref, nil
}

func (cc csvClassifierAttributes) InternalWithRef(ref terra.Reference) csvClassifierAttributes {
	return csvClassifierAttributes{ref: ref}
}

func (cc csvClassifierAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return cc.ref.InternalTokens()
}

func (cc csvClassifierAttributes) AllowSingleColumn() terra.BoolValue {
	return terra.ReferenceAsBool(cc.ref.Append("allow_single_column"))
}

func (cc csvClassifierAttributes) ContainsHeader() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("contains_header"))
}

func (cc csvClassifierAttributes) CustomDatatypeConfigured() terra.BoolValue {
	return terra.ReferenceAsBool(cc.ref.Append("custom_datatype_configured"))
}

func (cc csvClassifierAttributes) CustomDatatypes() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](cc.ref.Append("custom_datatypes"))
}

func (cc csvClassifierAttributes) Delimiter() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("delimiter"))
}

func (cc csvClassifierAttributes) DisableValueTrimming() terra.BoolValue {
	return terra.ReferenceAsBool(cc.ref.Append("disable_value_trimming"))
}

func (cc csvClassifierAttributes) Header() terra.ListValue[terra.StringValue] {
	return terra.ReferenceAsList[terra.StringValue](cc.ref.Append("header"))
}

func (cc csvClassifierAttributes) QuoteSymbol() terra.StringValue {
	return terra.ReferenceAsString(cc.ref.Append("quote_symbol"))
}

type grokClassifierAttributes struct {
	ref terra.Reference
}

func (gc grokClassifierAttributes) InternalRef() (terra.Reference, error) {
	return gc.ref, nil
}

func (gc grokClassifierAttributes) InternalWithRef(ref terra.Reference) grokClassifierAttributes {
	return grokClassifierAttributes{ref: ref}
}

func (gc grokClassifierAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return gc.ref.InternalTokens()
}

func (gc grokClassifierAttributes) Classification() terra.StringValue {
	return terra.ReferenceAsString(gc.ref.Append("classification"))
}

func (gc grokClassifierAttributes) CustomPatterns() terra.StringValue {
	return terra.ReferenceAsString(gc.ref.Append("custom_patterns"))
}

func (gc grokClassifierAttributes) GrokPattern() terra.StringValue {
	return terra.ReferenceAsString(gc.ref.Append("grok_pattern"))
}

type jsonClassifierAttributes struct {
	ref terra.Reference
}

func (jc jsonClassifierAttributes) InternalRef() (terra.Reference, error) {
	return jc.ref, nil
}

func (jc jsonClassifierAttributes) InternalWithRef(ref terra.Reference) jsonClassifierAttributes {
	return jsonClassifierAttributes{ref: ref}
}

func (jc jsonClassifierAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return jc.ref.InternalTokens()
}

func (jc jsonClassifierAttributes) JsonPath() terra.StringValue {
	return terra.ReferenceAsString(jc.ref.Append("json_path"))
}

type xmlClassifierAttributes struct {
	ref terra.Reference
}

func (xc xmlClassifierAttributes) InternalRef() (terra.Reference, error) {
	return xc.ref, nil
}

func (xc xmlClassifierAttributes) InternalWithRef(ref terra.Reference) xmlClassifierAttributes {
	return xmlClassifierAttributes{ref: ref}
}

func (xc xmlClassifierAttributes) InternalTokens() (hclwrite.Tokens, error) {
	return xc.ref.InternalTokens()
}

func (xc xmlClassifierAttributes) Classification() terra.StringValue {
	return terra.ReferenceAsString(xc.ref.Append("classification"))
}

func (xc xmlClassifierAttributes) RowTag() terra.StringValue {
	return terra.ReferenceAsString(xc.ref.Append("row_tag"))
}

type CsvClassifierState struct {
	AllowSingleColumn        bool     `json:"allow_single_column"`
	ContainsHeader           string   `json:"contains_header"`
	CustomDatatypeConfigured bool     `json:"custom_datatype_configured"`
	CustomDatatypes          []string `json:"custom_datatypes"`
	Delimiter                string   `json:"delimiter"`
	DisableValueTrimming     bool     `json:"disable_value_trimming"`
	Header                   []string `json:"header"`
	QuoteSymbol              string   `json:"quote_symbol"`
}

type GrokClassifierState struct {
	Classification string `json:"classification"`
	CustomPatterns string `json:"custom_patterns"`
	GrokPattern    string `json:"grok_pattern"`
}

type JsonClassifierState struct {
	JsonPath string `json:"json_path"`
}

type XmlClassifierState struct {
	Classification string `json:"classification"`
	RowTag         string `json:"row_tag"`
}
