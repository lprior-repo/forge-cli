package lingon

import (
	"fmt"
)

// ForgeStack represents a complete serverless application stack
// This is a simplified version that works without generated AWS provider
type ForgeStack struct {
	// Stack name
	Name string

	// Configuration
	Config ForgeConfig

	// Resources
	Functions map[string]*LambdaFunctionResources
	APIGateway *APIGatewayResources
	Tables    map[string]*DynamoDBTableResources

	// Outputs
	Outputs map[string]interface{}
}

// NewForgeStack creates a new Lingon stack from ForgeConfig
// This is a pure function that transforms configuration into Terraform resources
func NewForgeStack(config ForgeConfig) (*ForgeStack, error) {
	// Validate configuration first
	if err := validateConfig(config); err != nil {
		return nil, fmt.Errorf("invalid configuration: %w", err)
	}

	stack := &ForgeStack{
		Name:      config.Service,
		Config:    config,
		Functions: make(map[string]*LambdaFunctionResources),
		Tables:    make(map[string]*DynamoDBTableResources),
		Outputs:   make(map[string]interface{}),
	}

	// Create Lambda function resources
	for name, fnConfig := range config.Functions {
		resources, err := createLambdaFunctionResources(config.Service, name, fnConfig)
		if err != nil {
			return nil, fmt.Errorf("creating function %s: %w", name, err)
		}
		stack.Functions[name] = resources
	}

	// Create API Gateway resources if configured
	if config.APIGateway != nil {
		// Convert map to the format needed
		functionConfigs := make(map[string]FunctionConfig)
		for name, fn := range config.Functions {
			functionConfigs[name] = fn
		}

		resources, err := createAPIGatewayResources(config.Service, *config.APIGateway, functionConfigs)
		if err != nil {
			return nil, fmt.Errorf("creating API Gateway: %w", err)
		}
		stack.APIGateway = resources
	}

	// Create DynamoDB table resources
	for name, tableConfig := range config.Tables {
		resources, err := createDynamoDBTableResources(config.Service, name, tableConfig)
		if err != nil {
			return nil, fmt.Errorf("creating table %s: %w", name, err)
		}
		stack.Tables[name] = resources
	}

	return stack, nil
}

// ExportTerraform generates Terraform HCL from the stack
// This demonstrates the pattern - in actual implementation would use terra.Export
func (s *ForgeStack) ExportTerraform() ([]byte, error) {
	hcl := fmt.Sprintf(`# Generated by Forge using Lingon
# Service: %s

terraform {
  required_version = ">= 1.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "%s"
}

`, s.Name, s.Config.Provider.Region)

	// Add Lambda functions
	for name, resources := range s.Functions {
		hcl += fmt.Sprintf(`# Lambda Function: %s
resource "aws_iam_role" "%s_role" {
  name = "%s"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Principal = {
        Service = "lambda.amazonaws.com"
      }
      Action = "sts:AssumeRole"
    }]
  })
}

resource "aws_lambda_function" "%s" {
  function_name = "%s"
  runtime       = "%s"
  handler       = "%s"
  role          = aws_iam_role.%s_role.arn

  # Source code would be added here
  filename      = "lambda.zip"

  environment {
    variables = %s
  }
}

`,
			name,
			name,
			resources.Role.LocalName(),
			name,
			resources.Function.LocalName(),
			s.Config.Functions[name].Runtime,
			s.Config.Functions[name].Handler,
			name,
			formatEnvironment(s.Config.Functions[name].Environment),
		)

		// Add log group if configured
		if resources.LogGroup != nil {
			hcl += fmt.Sprintf(`resource "aws_cloudwatch_log_group" "%s_logs" {
  name              = "%s"
  retention_in_days = %d
}

`, name, resources.LogGroup.LocalName(), s.Config.Functions[name].Logs.RetentionInDays)
		}
	}

	// Add API Gateway if configured
	if s.APIGateway != nil {
		hcl += fmt.Sprintf(`# API Gateway
resource "aws_apigatewayv2_api" "api" {
  name          = "%s"
  protocol_type = "%s"
}

resource "aws_apigatewayv2_stage" "default" {
  api_id      = aws_apigatewayv2_api.api.id
  name        = "$default"
  auto_deploy = true
}

`, s.APIGateway.API.LocalName(), s.Config.APIGateway.ProtocolType)
	}

	// Add DynamoDB tables
	for name, resources := range s.Tables {
		tableConfig := s.Config.Tables[name]
		hcl += fmt.Sprintf(`# DynamoDB Table: %s
resource "aws_dynamodb_table" "%s" {
  name           = "%s"
  billing_mode   = "%s"
  hash_key       = "%s"

`, name, name, resources.Table.LocalName(), tableConfig.BillingMode, tableConfig.HashKey)

		// Add attributes
		for _, attr := range tableConfig.Attributes {
			hcl += fmt.Sprintf(`  attribute {
    name = "%s"
    type = "%s"
  }

`, attr.Name, attr.Type)
		}

		hcl += "}\n\n"
	}

	// Add outputs
	hcl += "# Outputs\n"
	for name := range s.Functions {
		hcl += fmt.Sprintf(`output "%s_function_arn" {
  value = aws_lambda_function.%s.arn
}

`, name, name)
	}

	if s.APIGateway != nil {
		hcl += `output "api_endpoint" {
  value = aws_apigatewayv2_api.api.api_endpoint
}
`
	}

	return []byte(hcl), nil
}

// Helper function to format environment variables as HCL
func formatEnvironment(env map[string]string) string {
	if len(env) == 0 {
		return "{}"
	}

	result := "{\n"
	for k, v := range env {
		result += fmt.Sprintf("      %s = \"%s\"\n", k, v)
	}
	result += "    }"
	return result
}

// GetOutputs returns stack outputs after Terraform apply
func (s *ForgeStack) GetOutputs() map[string]interface{} {
	return s.Outputs
}
