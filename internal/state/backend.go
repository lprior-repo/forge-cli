package state

import (
	"fmt"
	"strings"
)

// BackendConfig represents Terraform backend configuration (immutable data)
type BackendConfig struct {
	Bucket         string
	Key            string
	Region         string
	DynamoDBTable  string
	Encrypt        bool
	EnableLocking  bool
}

// S3BucketSpec represents S3 bucket configuration (immutable data)
type S3BucketSpec struct {
	Name          string
	Region        string
	EnableLogging bool
	Tags          map[string]string
}

// DynamoDBTableSpec represents DynamoDB table configuration (immutable data)
type DynamoDBTableSpec struct {
	Name           string
	Region         string
	BillingMode    string
	HashKey        string
	Tags           map[string]string
}

// StateResources represents complete state backend resources (immutable data)
type StateResources struct {
	S3Bucket      S3BucketSpec
	DynamoDBTable DynamoDBTableSpec
	BackendConfig BackendConfig
}

// GenerateStateBucketName creates a bucket name from project name (PURE)
// Pattern: forge-state-{project}-{hash}
func GenerateStateBucketName(projectName string) string {
	// Normalize project name for S3 bucket naming rules
	normalized := strings.ToLower(projectName)
	normalized = strings.ReplaceAll(normalized, "_", "-")

	// S3 buckets must be globally unique, so we'll add a suffix
	// For now, just use the project name - user can customize if needed
	return fmt.Sprintf("forge-state-%s", normalized)
}

// GenerateLockTableName creates a DynamoDB table name from project name (PURE)
// Pattern: forge-locks-{project}
func GenerateLockTableName(projectName string) string {
	normalized := strings.ToLower(projectName)
	normalized = strings.ReplaceAll(normalized, "-", "_")
	return fmt.Sprintf("forge_locks_%s", normalized)
}

// GenerateStateKey creates a namespace-aware state key (PURE)
// With namespace: {namespace}/terraform.tfstate
// Without namespace: terraform.tfstate
func GenerateStateKey(namespace string) string {
	if namespace != "" {
		return fmt.Sprintf("%s/terraform.tfstate", namespace)
	}
	return "terraform.tfstate"
}

// GenerateS3BucketSpec creates S3 bucket specification (PURE calculation)
func GenerateS3BucketSpec(projectName, region string) S3BucketSpec {
	bucketName := GenerateStateBucketName(projectName)

	return S3BucketSpec{
		Name:          bucketName,
		Region:        region,
		EnableLogging: false, // Can be enabled in future
		Tags: map[string]string{
			"Project":    projectName,
			"ManagedBy":  "forge",
			"Purpose":    "terraform-state",
		},
	}
}

// GenerateDynamoDBTableSpec creates DynamoDB table specification (PURE calculation)
func GenerateDynamoDBTableSpec(projectName, region string) DynamoDBTableSpec {
	tableName := GenerateLockTableName(projectName)

	return DynamoDBTableSpec{
		Name:        tableName,
		Region:      region,
		BillingMode: "PAY_PER_REQUEST", // On-demand pricing for state locks
		HashKey:     "LockID",
		Tags: map[string]string{
			"Project":   projectName,
			"ManagedBy": "forge",
			"Purpose":   "terraform-state-locking",
		},
	}
}

// GenerateBackendConfig creates backend configuration (PURE calculation)
func GenerateBackendConfig(projectName, region, namespace string) BackendConfig {
	bucketName := GenerateStateBucketName(projectName)
	tableName := GenerateLockTableName(projectName)
	stateKey := GenerateStateKey(namespace)

	return BackendConfig{
		Bucket:        bucketName,
		Key:           stateKey,
		Region:        region,
		DynamoDBTable: tableName,
		Encrypt:       true,
		EnableLocking: true,
	}
}

// GenerateStateResources creates complete state backend specification (PURE calculation)
// This is the main entry point for generating state backend configuration
func GenerateStateResources(projectName, region, namespace string) StateResources {
	return StateResources{
		S3Bucket:      GenerateS3BucketSpec(projectName, region),
		DynamoDBTable: GenerateDynamoDBTableSpec(projectName, region),
		BackendConfig: GenerateBackendConfig(projectName, region, namespace),
	}
}

// RenderBackendTF generates backend.tf content (PURE calculation)
func RenderBackendTF(config BackendConfig) string {
	var sb strings.Builder

	sb.WriteString("# Auto-generated by Forge - Terraform state backend configuration\n")
	sb.WriteString("# This file configures S3 backend with DynamoDB state locking\n\n")

	sb.WriteString("terraform {\n")
	sb.WriteString("  backend \"s3\" {\n")
	sb.WriteString(fmt.Sprintf("    bucket         = \"%s\"\n", config.Bucket))
	sb.WriteString(fmt.Sprintf("    key            = \"%s\"\n", config.Key))
	sb.WriteString(fmt.Sprintf("    region         = \"%s\"\n", config.Region))
	sb.WriteString(fmt.Sprintf("    encrypt        = %t\n", config.Encrypt))

	if config.EnableLocking {
		sb.WriteString(fmt.Sprintf("    dynamodb_table = \"%s\"\n", config.DynamoDBTable))
	}

	sb.WriteString("  }\n")
	sb.WriteString("}\n")

	return sb.String()
}

// RenderS3BucketTF generates Terraform code for S3 bucket (PURE calculation)
// This creates a temporary .tf file that can be applied to provision the bucket
func RenderS3BucketTF(spec S3BucketSpec) string {
	var sb strings.Builder

	sb.WriteString("# Auto-generated by Forge - S3 state bucket\n\n")

	sb.WriteString("resource \"aws_s3_bucket\" \"terraform_state\" {\n")
	sb.WriteString(fmt.Sprintf("  bucket = \"%s\"\n\n", spec.Name))

	sb.WriteString("  tags = {\n")
	for k, v := range spec.Tags {
		sb.WriteString(fmt.Sprintf("    %s = \"%s\"\n", k, v))
	}
	sb.WriteString("  }\n")
	sb.WriteString("}\n\n")

	// Enable versioning for state history
	sb.WriteString("resource \"aws_s3_bucket_versioning\" \"terraform_state\" {\n")
	sb.WriteString("  bucket = aws_s3_bucket.terraform_state.id\n\n")
	sb.WriteString("  versioning_configuration {\n")
	sb.WriteString("    status = \"Enabled\"\n")
	sb.WriteString("  }\n")
	sb.WriteString("}\n\n")

	// Enable encryption
	sb.WriteString("resource \"aws_s3_bucket_server_side_encryption_configuration\" \"terraform_state\" {\n")
	sb.WriteString("  bucket = aws_s3_bucket.terraform_state.id\n\n")
	sb.WriteString("  rule {\n")
	sb.WriteString("    apply_server_side_encryption_by_default {\n")
	sb.WriteString("      sse_algorithm = \"AES256\"\n")
	sb.WriteString("    }\n")
	sb.WriteString("  }\n")
	sb.WriteString("}\n\n")

	// Block public access
	sb.WriteString("resource \"aws_s3_bucket_public_access_block\" \"terraform_state\" {\n")
	sb.WriteString("  bucket = aws_s3_bucket.terraform_state.id\n\n")
	sb.WriteString("  block_public_acls       = true\n")
	sb.WriteString("  block_public_policy     = true\n")
	sb.WriteString("  ignore_public_acls      = true\n")
	sb.WriteString("  restrict_public_buckets = true\n")
	sb.WriteString("}\n")

	return sb.String()
}

// RenderDynamoDBTableTF generates Terraform code for DynamoDB table (PURE calculation)
func RenderDynamoDBTableTF(spec DynamoDBTableSpec) string {
	var sb strings.Builder

	sb.WriteString("# Auto-generated by Forge - DynamoDB state locking table\n\n")

	sb.WriteString("resource \"aws_dynamodb_table\" \"terraform_locks\" {\n")
	sb.WriteString(fmt.Sprintf("  name         = \"%s\"\n", spec.Name))
	sb.WriteString(fmt.Sprintf("  billing_mode = \"%s\"\n", spec.BillingMode))
	sb.WriteString(fmt.Sprintf("  hash_key     = \"%s\"\n\n", spec.HashKey))

	sb.WriteString("  attribute {\n")
	sb.WriteString(fmt.Sprintf("    name = \"%s\"\n", spec.HashKey))
	sb.WriteString("    type = \"S\"\n")
	sb.WriteString("  }\n\n")

	sb.WriteString("  tags = {\n")
	for k, v := range spec.Tags {
		sb.WriteString(fmt.Sprintf("    %s = \"%s\"\n", k, v))
	}
	sb.WriteString("  }\n")
	sb.WriteString("}\n")

	return sb.String()
}

// RenderStateBootstrapTF generates complete bootstrap Terraform (PURE calculation)
// This combines S3 bucket + DynamoDB table into a single .tf file for provisioning
func RenderStateBootstrapTF(resources StateResources) string {
	var sb strings.Builder

	sb.WriteString("# Auto-generated by Forge - State backend bootstrap\n")
	sb.WriteString("# This file provisions S3 bucket and DynamoDB table for Terraform state\n")
	sb.WriteString("# Run: terraform init && terraform apply\n")
	sb.WriteString("# After applying, this file can be deleted\n\n")

	sb.WriteString(fmt.Sprintf("provider \"aws\" {\n  region = \"%s\"\n}\n\n", resources.S3Bucket.Region))

	sb.WriteString(RenderS3BucketTF(resources.S3Bucket))
	sb.WriteString("\n")
	sb.WriteString(RenderDynamoDBTableTF(resources.DynamoDBTable))

	return sb.String()
}
